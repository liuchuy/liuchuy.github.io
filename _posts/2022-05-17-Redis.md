Redis

# 一：缓存概念

缓存是为了调节速度不一致的两个或多个不同的物质的速度，在中间对毒素较快的一方起到了一个加速访问速度较慢的一方的作用，比如CPU一级、二级缓存是保存了CPU最近经常访问的数据，内存是保存CPU经常访问硬盘的数据，而且硬盘也有大小不一的缓存，甚至是物理服务器的raid卡有也缓存，都是为了起到加速CPU访问硬盘数据的目的，因为CPU的速度太快了，CPU需要的数据由于硬盘往往不能在短时间内满足CPU的需求，因此CPU缓存、内存、Reid卡缓存以及硬盘缓存就存在一定程度上满足了CPU的数据需求，既CPU从缓存读取数据可以大幅提高CPU的工作效率



![](/images/posts/06_redis/00/1.png)



## 1.1：系统缓存

### 1.1.1：buffer与cache

buffer：缓冲也叫写缓冲，一般用于写操作，可以将数据先写入内存在写入磁盘，buffer一般用于写缓冲，用于解决不同介质的速度不一致的缓冲，先将数据先写到内存的磁盘缓冲区，然后就认为数据已经写入完成看，然后由内核在后续的时间在写入磁盘，所有服务器突然断电会丢失内存中的部分数据



cache:缓存也叫读缓存，一般用于读操作，CPU读文件从内存读，如果内存没有就先从硬盘读到内存在读到CPU，将需要频繁读取的数据放在离自己最近的缓存区域，下次读取的时候即可快速读取

### 1.1.2：cache的保存位置

客户端：浏览器内存：本地服务器、远程服务器、硬盘：本机硬盘

### 1.1.3：cache的特性

自动过期：给缓存的数据加上有效时间，超出时间后自动过期删除过期时间：强制过期，源网站更新图片后CDN是不会更新的，需要强制是土拍你缓存过期命中率：既缓存的读取命中率



## 1.2：其它层面缓存



### 1.2.1：CPU缓存

CPU缓存（L1的数据缓存和L1的指令缓存）、二级缓存、三级缓存



### 1.2.2：cookie与session

Cookie是访问某些网站以后在本地存储的一些网站相关的信息，下次在访问的时候减少一些步骤，比如加密后的账户名密码等信息Cookied是服务器在客户端浏览器上存储的小段文本随每一个请求发送至同一个服务器，是一种实现客户端保存状态的方案，session称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互当浏览器请求Http地址时，可以基于之前的session实现会话保持、session共享等

### 1.2.3：session与cookie的区别

1、cookie以文本文件格式存储在浏览器中，而session存储在服务端

2、cookie的存储限制了数据量，只允许4kb，而session是无限制的

3、cookie包含在每一个客户端请求报文中，因此容器被人捕获

4、cookie和session都可以设置过期时间











# 二：redis部署与使用：

## 2.1：redis基础：

官网地址：https://redis.io/

Redis和Memcache是非关系型数据库也称为NoSQL数据库，MySQL、Mariadb、SQL Server、PostgreSQL、Oracle数据库属于关系型数据

### 2.1.1：redis简介：

Redis（Remote Dictionary Server）在2009年发布，开发者Salvatore Sanfilippo 是意大利开发者，他本想为自己的开发一个用于替换MsSQL的产品Redis，但是没有想到他把Redis开源后大受欢迎，短短几年，Redis就有了很大的用户群体，目前国内外使用的公司有知乎网、新浪微博等

redis是一个开源的、遵循BSD协议的、基于内存的而且目标比较流行的键值数据库，是一个非关系型数据库,redis提供将内存通过网络远程共享的一种服务，提供类似功能的还有memcache，但相比memcache，redis还提供了易扩展、高性能、具备数据持久性等功能

Redis在高并发、低延迟环境要求比较高的环境使用非常广范，目前redis在DB-Engine月排行榜https://db-engines.com/en/ranking中一直比较靠前，而且一致是键值型存储类的首位

![](/images/posts/06_redis/00/2.png)



### 2.1.2：redis对比memcached:

支持数据持久化：可以将内存中的数据保存在磁盘中，重启redis服务或者服务器之后可以从备份文件中恢复数据到内存继续使用

```
支持更多的数据类型：支持string(字符串)、hash（哈希数据）、list(列表)、set(集合)、zet(有序集合)
支持数据的备份：可以实现类似于数据的master-slave模式的数据备份，另外也支持使用快照+AOF
支持更多的value数据：memcache单个key value最大只支持1MB，而redis最大支持512MB
Redis是单线程，而memcache是多线程，所以单机情况下没有memcache并发高，但redis支持分布式集群以实现更高的并发，单Redis实例可以实现数万并发
支持集群横向扩展：基于redis cluster的横向扩展，可以实现分布式集群，大幅提升性能和数据安全性
都是基于c语言开发
```





### 2.1.3: redis典型应用场景：

```
Session共享：常见于Web集群中的Tomcat或者PHP中多web服务器session共享
消息队列：ELK的日志缓存、部分业务的订阅发布系统
计数器：访问排行榜、商品浏览数等和次数相关的数值统计场景
缓存：数据库查询缓存、电商网站商品信息、新闻内容
微博/微信社交场合：共同好友、点赞评论等
```



## 2.2：Redis安装及使用：

官方下载地址：http://download.redis.io/releases/



### 2.2.1：apt安装redis:

#### 2.2.1.1: 查看apt仓库redis版本

![](/images/posts/06_redis/00/3.png)



#### 2.2.1.2：安装reids：

```
root@redis:~# apt-get install redis
root@redis:~# systemctl start redis
root@redis:~# redis-cli
127.0.0.1:6379> info
# Server
redis_version:4.0.9
redis_git_sha1:00000000
redis_git_dirty:0
redis_build_id:9435c3c2879311f3
redis_mode:standalone
os:Linux 5.4.0-84-generic x86_64
arch_bits:64


```



### 2.2.2：编译安装redis：

下载当前最新release版本redis源码包：http://download.redis.io/releases/



![](/images/posts/06_redis/00/4.png)

#### 2.2.2.1：编译安装命令：

官方的安装命令：

https://redis.io/download/

```
root@redis:~# apt install iproute2 ntpdate tcpdump telnet libjemalloc-dev libsystemd-dev openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev gcc lrzsz unzip zip make
#pwd
/usr/local/src
root@redis: wget http://download.redis.io/releases/redis-6.2.2.tar.gz
root@redis:/usr/local/src# tar xf redis-6.2.2.tar.gz 
root@redis:/usr/local/src# cd redis-6.2.2
root@redis:/usr/local/src/redis-6.2.2# make USE_SYSTEMD=yes PREFIX=/apps/redis install


#创建配置文件、日志、数据等目录
root@redis:/data# mkdir /apps/redis/{etc,logs,data,run}

root@redis:/usr/local/src/redis-6.2.2# cp redis.conf /apps/redis/etc/

```



#### 2.2.2.2：前台启动redis:



![](/images/posts/06_redis/00/5.png)

#### 2.2.2.3: 解决当前的警告提示

##### 2.2.2.3.1:tcp-backlog:

backlog参数控制的是三次握手的时候server端收到client ack确认号之后的队列值

```
vim /etc/sysctl.conf
net.core.somaxconn = 512
```

##### 2.2.2.3.2: vm.overcommit_memory:

0 表示内核将检查是否有足够的可用内存供应进程使用，如果有足够的可用内存，内存申请运行，否则申请失败

1 表示内核运行分配所有的物理内存，而不管当前的内存状态如何

2 表示内核允许分配超过所有物理内存和交换空间总和的内存



```
root@redis:~# vim /etc/sysctl.conf
root@redis:~# sysctl -p
vm.overcommit_memory = 1
```

##### 2.2.2.3.3: transparent hugepage:

大页内存动态分配，需要关闭让redis负责内存管理

```
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```



##### 2.2.2.3.4：再次启动redis



![](/images/posts/06_redis/00/6.png)



#### 2.2.2.4：创建redis用户

```
#创建redis用户使用普通用户启动
root@redis:/usr/local/src/redis-6.2.2# groupadd -g 1000 redis && useradd redis -u 1000 -g 1000 -s /sbin/nologin
root@redis:/usr/local/src/redis-6.2.2# chown redis.redis /apps/ -R
```



#### 2.2.2.5：编辑redis启动脚本：

```
#拷贝启动脚本
root@redis:/usr/local/src/redis-6.2.2# cp utils/systemd-redis_server.service /lib/systemd/system/redis.service

root@redis:/usr/local/src/redis-6.2.2# cat /lib/systemd/system/redis.service 
# example systemd service unit file for redis-server
#
# In order to use this as a template for providing a redis service in your
# environment, _at the very least_ make sure to adapt the redis configuration
# file you intend to use as needed (make sure to set "supervised systemd"), and
# to set sane TimeoutStartSec and TimeoutStopSec property values in the unit's
# "[Service]" section to fit your needs.
#
# Some properties, such as User= and Group=, are highly desirable for virtually
# all deployments of redis, but cannot be provided in a manner that fits all
# expectable environments. Some of these properties have been commented out in
# this example service unit file, but you are highly encouraged to set them to
# fit your needs.
#
# Please refer to systemd.unit(5), systemd.service(5), and systemd.exec(5) for
# more information.

[Unit]
Description=Redis data structure server
Documentation=https://redis.io/documentation
#Before=your_application.service another_example_application.service
#AssertPathExists=/var/lib/redis
Wants=network-online.target
After=network-online.target

[Service]
ExecStart=/apps/redis/bin/redis-server /apps/redis/etc/redis.conf --supervised systemd --daemonize no
## Alternatively, have redis-server load a configuration file:
#ExecStart=/usr/local/bin/redis-server /path/to/your/redis.conf
LimitNOFILE=65535
NoNewPrivileges=yes
#OOMScoreAdjust=-900
#PrivateTmp=yes
Type=notify
TimeoutStartSec=infinity
TimeoutStopSec=infinity
UMask=0077
User=redis
Group=redis
WorkingDirectory=/apps/redis

[Install]
WantedBy=multi-user.target


```



#### 2.2.2.5：验证redis启动

```
root@redis:/usr/local/src# systemctl start redis
```

![](/images/posts/06_redis/00/7.png)



#### 2.2.2.6: 创建命令软连接：

```
root@redis:~# ln -sv /apps/redis/bin/redis-* /usr/bin/
'/usr/bin/redis-benchmark' -> '/data/redis/bin/redis-benchmark'
'/usr/bin/redis-check-aof' -> '/data/redis/bin/redis-check-aof'
'/usr/bin/redis-check-rdb' -> '/data/redis/bin/redis-check-rdb'
'/usr/bin/redis-cli' -> '/data/redis/bin/redis-cli'
'/usr/bin/redis-sentinel' -> '/data/redis/bin/redis-sentinel'
'/usr/bin/redis-server' -> '/data/redis/bin/redis-server'

```



#### 2.2.2.7：编译安装后的命令：

```
root@redis:~# ll /apps/redis/bin/
total 20824
-rwxr-xr-x 1 redis redis  5593704 5月   4 14:24 redis-benchmark*  #reids性能测试工具
lrwxrwxrwx 1 redis redis       12 5月   4 14:24 redis-check-aof  #AOF文件检查工具
lrwxrwxrwx 1 redis redis       12 5月   4 14:24 redis-check-rdb #RDB文件检查工具
-rwxr-xr-x 1 redis redis  5443744 5月   4 14:24 redis-cli* #客户端工具
lrwxrwxrwx 1 redis redis       12 5月   4 14:24 redis-sentinel  #哨兵
-rwxr-xr-x 1 redis redis 10269760 5月   4 14:24 redis-server* #redis服务启动命令

```



### 2.2.3：连接到Redis:

主要分配运维人员的连接和程序的连接

#### 2.2.3.1：本机非密码连接：

```
#redis-cli
```

#### 2.2.3.2：跨主机非密码连接

```
#redis-cli -h hosntmae/ip -p port
```

#### 2.2.3.3: 跨主机密码连接

```
#redis-cli -h hosntmae/ip -p port -a password
```

#### 2.2.3.4:shell脚本写入数据到redis

##### 2.2.3.4.1：shell脚本内容：

```
#!/bin/bash
NUM=`seq 1 100`
for i in ${NUM};do
	redis-cli -h 127.0.0.1 set key-${i} value-${i}
       echo "key-${i} value-${i} 写入完成"
done
	echo "100个key写入到redis完成"
```

![](/images/posts/06_redis/00/8.png)



## 2.3：redis配置文件

### 2.3.1：redis主要配置项：

```
bind 0.0.0.0  #监听地址，可以用空格隔开多个监听IP
protected-mode yes #redis3.2之后加入的新特性，在没有设置bind ip和密码的时候redis只允许访问127.0.0.1:6379，远程访问将提示警告信息并拒绝访问
port 6379 #监听端口
tcp-backlog 511 #三次握手的时候server端收到client ack确认号之后的队列值
timeout 0 #客户端和redis服务端的连接超时时间，默认是0，表示永不超时
tcp-keepalive 300 #tcp 会话保持时间
daemonize no #默认情况下redis不是作为守护进程运行的，如果你想让他在后台运行，你就把它改成yes，当redis作为守护进程运行时，他会写一个pid到/var/run/redis.pid文件里面
#supervised auto #和操作系统相关参数，可以设置通过upstart和systemd管理redis守护进程，centos7以后都使用systemd

pidfile /var/run/redis_6379.pid #pid文件路径
loglevel notice #日志级别
logfile "" #日志路径

databases 16  #设置bd库数量，默认16个库
always-show-logo no #在启动redis时是否显示Log

 save 3600 1 #在3600秒内有一个键内容发生更改就出快照机制
 save 300 100
 save 60 10000

stop-writes-on-bgsave-error no #快照出错时是否禁止redis写入操作

rdbcompression yes #持久化到RDB文件时，是否压缩，yes为压缩，no则反之

rdbchecksum yes #是否开启RC64检验，默认是开启
dbfilename dump.rdb #快照文件名

rdb-del-sync-files no # #在没有开启数据持久化的情况下删除复制中使用的RDB文件
dir ./ #快照及AOF持久化文件的保存路径

 
replica-serve-stale-data yes #当从库同主库失去连接或者复制正在进行，从库有两种方式：
1、如果replica-serve-stale-data设置为yes（默认设置），从库会继续响应客户端的读请求
2、如果replica-server-stale-data设置为no，除去指定的命令之外的任何请求都会返回一个错误“SYNV with master in progress”

replica-read-only yes #是否设置从库只读

repl-diskless-sync no #是否使用socker方式复制数据（无盘同步），新slave连接时候需要做数据的全量不同，redis server就要内从内存dump出新的RDB文件，然后从master传到slave，有两种方式把RDB文件传输给客户端
1、基于硬盘（disk-backed）:master创建一个新进程dump RDB,RDB完成之后由父进程（既主进程）传给slaves
2、基于socker（diskless）:master创建一个新进行直接dump RDB到slave的socker，不经过主进程，不经过硬盘
基于硬盘的话,RDB文件创建后，一旦创建完毕，可以同时服务更多的slave，但是基于socker的话，新slave连接到master之后得琢哥同步数据，在磁盘较慢并且网络较快得时候，可以用diskless(yes)否则使用磁盘(no)
repl-diskless-sync-delay 5 #diskless复制得延迟时间，设置0为关闭，在延迟时间内连接得新客户端，会一起通过disk方式同步数据，但是一旦复制开始还没有结束之前，master节点不会在接收新slave得复制请求，直到下一次同步开始
repl-ping-slave-period 10#slave根据master指定得时间进行周期性得PING检查
repl-timeout 60 #复制连接得超时时间，需要大于repl-ping-slave-period,否则胡经常报超时
repl-disable-tcp-nodelay no #在socker模式下是否在slave套接字发送SYNV之后禁用TCP_NODELAY
repl-backlog-size 512mb #复制缓冲区内存大小，只要在slave连接之后才分配内存
repl-backlog-ttl 300 #多次时间master没有slave连接，就清空backlog缓冲区
replica-priority 100 #当master不可用,sentinel会根据slave的优先级选举一个master，最低的优先级的slave当选master，而配置成0，永远不会被选举
 requirepass foobared #设置redis连接密码
rename-command #重命名一些高危命令
 maxclients 10000 #redis最大连接客户端
maxmemory #最大内存，单位为bytest字节，8g内存计算方式8G1024（MB）1024（KB）*1024（kbyte）需要的是slave的输出缓冲区是不计算在maxmemory内


appendonly no #是否开启AOF日志记录，默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了，但是redis如果中途冗机，会导致可能有几分钟的数据丢失（取决于dumpd数据的间隔时间）根据save来策略进行持久化，Append only File 是另一种持久化方式，可以提供更好的持久化特性，redis会把每次写入的数据在接收后都写入appendonly.aof文件，每次启动时redis都会先把这个文件的数据读入内存里，先忽略RDB文件

appendfilename "appendonly.aof" #AOF文件名
appendfsync everysec #aof持久化策略的配置，no表示不执行fsynv，由操作系统保证数据同步到磁盘,always表示每次写入都执行fsynv，以保证数据同步到磁盘，everysec表示每秒执行一次fsynv，可能会导致丢失这1s数据

no-appendfsync-on-rewrite no #在aof rewrite期间，是否对aof新记录的append暂缓使用文件同步策略，主要考虑磁盘IO开支和请求阻塞时间，默认为no表示不暂缓新的aof记录仍会会立即同步，linux的默认fsynv策略时30秒，如果为yes可能丢失30秒数据，但由于yes性能较好而会避免出现阻塞因此比较推荐

auto-aof-rewrite-percentage 100 #当aoflog增长超过指定百分比列时，重写AOF文件，设置为0表水不自动重写AOF日志，重写时为了使aof体积保持最小，但是还可以确保保存最完整的数据
auto-aof-rewrite-min-size 64mb #触发aof rewrite的最下文件大小
aof-load-truncated yes #是否加载由于其它原因导致的末尾异常的AOF文件

aof-use-rdb-preamble yes #reids4.0新增RDB-AOF混合持久化格式，在开启了这个功能之后，AOF重写产生的文件将同时包含RDB格式的内容和AOF格式的内容，其中RDB格式的内容用于记录已有的数据，而AOF格式的内存则用于记录最近发生了变化的数据，这样redis就可以同时兼有RDB持久化和AOF持久化的优点，（既能快速的生成重写文件，也能够在出现问题时，快速地载入数据）
lua-time-limit 5000 #lus脚本的最大执行时间，单位为毫秒
cluster-enabled yes #是否开启集群模式，默认时单机模式
 cluster-config-file nodes-6379.conf #由Node节点自动生成的集群配置文件
 cluster-node-timeout 15000 #集群中Node节点连接超时时间
 cluster-replica-validity-factor 30 #在执行故障转移的时候可能有些节点和master断开一段时间数据比较旧，这些节点就不适用于选举为master，超过这个时间就不会被进行故障转移
 cluster-migration-barrier 1 #集群迁移屏障，一个主节点拥有的至少工作的从节点，既如果主机点的slave节点故障后会将多余的从节点分配到当前主节点成为新的从节点
 cluster-require-full-coverage no #集群请求槽位全部覆盖，如果一个主库冗机且没有备库就会出现集群槽位不全，那么yes情况下redis集群槽位验证不全就不在对外提供服务，而no则可以继续使用但是会出现查询数据不到的情况（因为有数据丢失）
 #slow log是redis用来记录查询执行时间的日志系统，slow log保存在内存里面，续写速度非常快，因此你可以方向的使用它，不必担心因为开启slow log而损害redis的速度
slowlog-log-slower-than 10000 #以微妙为单位的慢日志记录，为负数会禁用慢日志，为0会记录每个命令操作
slowlog-max-len 128 #记录多少条慢日志保存在队列，超出后会删除最早的，一次滚动删除


```



### 2.3.2：redis持久化

Redis虽然是一个内存级别的缓存程序，也就是redis是使用内存进行数据的缓存的，但是其可以将内存的数据按照一定的策略保存到硬盘上，从而实现数据持久保存的目的，目前redis支持两种不同方式的数据持久化保存机制，分别是RDB和AOF



#### 2.3.2.1：RDB模式

RDB（Redis DataBase）:基于时间的快照，其默认只保留当前最新的一次快照，特点是执行速度比较快，缺点是可能会丢失从上次快照到当前时间点之间未作快照的数据

RDB实现的具体过程Redis从主进程先fork出一个子进程，使用写时复制，子进程将内存的数据保存为一个临时文件，比如dump.rdb.temp，当数据保存完成之后再将上一次保存的RDB文件替换掉，然后关闭子进程，这样可以保证每一次做RDB快照的时候保存的数据都是完整的，因为直接替换RDB文件的时候可能出现突然断电等问题而导致RDB文件还没有保存完整就突然关机停止导致数据丢失的情况，可以手动将每次生成的RDB文件进程备份，这样可以最大化保存历史数据



![](/images/posts/06_redis/00/9.png)



#### 2.3.2.2：RDB模式的优缺点：

优点: RDB快照保存了某个时间点的数据，可以通过脚本执行bgsave（非阻塞）或者save（阻塞）命令自定义时间点备份，可以保留多个备份，当出现问题可以恢复到不同时间点的版本，可以最大化IO性能，因为父进程在保存RDB文件的时候要唯一要做的事fork出一个子进程，然后的操作都会有这个子进程操作，父进程无需任何的IO操作RDB在大量数据比如几个G的数据，恢复的速度比AOF的快



缺点：不能时时的保存数据，会丢失自上一次执行RDB备份到当前的内存数据，数据量非常大的时候，从父进程fork的时候需要一点时间，可能是毫秒或者秒或者分支，取决于磁盘IO性能



#### 2.3.2.3：AOF模式：

AOF：按照操作顺序依次将操作添加到指定的日志文件中，特点是数据安全性相对较高，缺点是即使有些操作时重复的也会全部记录

AOF和RDB一样使用了写时复制机制，AOF默认为每秒钟fsync一次，既将执行的命令保存到AOF文件当中，这样即使redis服务器发生故障的话顶多也就丢失1秒钟之内的数据，也可也设置不同的fsync策略，或者设置每次执行命令的时候执行fsync，fsync会在后台执行线程，所以主线程可以继续出来用户的正常请求而不受到写入AOF文件的IO影响



#### 2.3.2.4：AOF模式优缺点：

AOF的文件大小要大于RDB格式的文件

根据所使用的fsync策略fsync时同步内存中redis所有已修改的文件到存储设备，默认时appendfsync enverysec既每秒执行一次fsync



## 2.4:redis 数据类型：

http://www.redis.cn/topics/data-types.html



### 2.4.1：字符串（string）:

字符串是所有编程语言中最常见的最常用的数据类型，而且也是redis最基本的数据类型之一，而且redis中所有的key的类型都是字符串

#### 2.4.1.1：添加一个key

```
root@redis:~# redis-cli 
127.0.0.1:6379> set key1 value1
OK
127.0.0.1:6379> get key1
"value1"
127.0.0.1:6379> type key1
string
127.0.0.1:6379> set name2 jack2 ex 3 #设置自动过期时间
OK
127.0.0.1:6379> ttl name2
(integer) 1

```



#### 2.4.1.2：获取一个key的内容

```
127.0.0.1:6379> get key1
"value1"

```

#### 2.4.1.3：删除一个key

```
127.0.0.1:6379> DEL key1
(integer) 1

```



#### 2.4.1.4: 批量设置多个key

```
127.0.0.1:6379> MSET key1 value1 key2 value2
OK

```

#### 2.4.1.5: 批量获取多个key

```
127.0.0.1:6379> MGET key1 key2
1) "value1"
2) "value2"
```

#### 2.4.1.6：追加数据：

```
127.0.0.1:6379> APPEND key1 append
(integer) 12
127.0.0.1:6379> get key1
"value1append"

```

#### 2.4.1.7：数值递增

```
127.0.0.1:6379> set num 10
OK
127.0.0.1:6379> INCR num
(integer) 11
127.0.0.1:6379> get num
"11"

```

#### 2.4.1.8：数值递减

```
127.0.0.1:6379> set num 10
OK
127.0.0.1:6379> DECR num
(integer) 9
127.0.0.1:6379> get num
"9"

```

#### 2.4.1.9：返回字符串key长度

```
127.0.0.1:6379> STRLEN key1
(integer) 12
```

#### 2.4.1.10：判断key是否存在

```
127.0.0.1:6379> EXISTS key1
(integer) 1
127.0.0.1:6379> EXISTS key3
(integer) 0

```

#### 2.4.1.11：查看key的过期时间

```
ttl #查看key的剩余生存时间
	-1 #负一为永不过期，默认创建的key是永不过期，重新对key赋值，也会从有剩余生命周期变成永不过期
	-2 #为没有此key
	num #key的剩余有效期
127.0.0.1:6379> TTL key1
(integer) -1
```

#### 2.4.1.12：设置key的过期时间

```
127.0.0.1:6379> EXPIRE key1 100
(integer) 1

```

#### 2.4.1.13：取消key的过期时间

```
127.0.0.1:6379> PERSIST key1
(integer) 1

```

### 2.4.2：列表（list）

列表是一个双向可读可写的管道，其头部是左侧尾部是右侧，一个列表最多包含2^32-1个元素既4294967295个元素

#### 2.4.2.1：生成列表并插入数据

```
127.0.0.1:6379> LPUSH list1 jack tom jhon #根据顺序琢哥写入list1,最后的jhon会在列表的最左侧
(integer) 3
127.0.0.1:6379> TYPE list1
list
```

#### 2.4.2.2：向列表追加数据

```
127.0.0.1:6379> LPUSH list1 tom
(integer) 4
127.0.0.1:6379> RPUSH list1 jack
(integer) 5

```

#### 2.4.2.3：获取列表长度：

```
127.0.0.1:6379> LLEN list1
(integer) 5

```

#### 2.4.2.4：获取列表指定位置数据

```
127.0.0.1:6379> RPUSH list1 zhang wang li zhao
(integer) 9

127.0.0.1:6379> LRANGE list1 7 8 #指定范围，index(下标)
1) "li"
2) "zhao"
127.0.0.1:6379> LRANGE list1 2 2 #指定位置
1) "tom"

```

#### 2.4.2.5：移除列表数据

```
127.0.0.1:6379> RPOP list1
"zhao"
127.0.0.1:6379> LPOP list1
"tom"

```

### 2.4.3：集合（set）

set 是string类型的无序集合，集合中的成员是唯一的，这就意味着集合中不能出现重复的数据，可以在不同的集合中对数据进行对比并取值

#### 2.4.3.1：生成集合key

```
127.0.0.1:6379> SADD set1 v1
(integer) 1
127.0.0.1:6379> SADD set2 v2 v4
(integer) 2
127.0.0.1:6379> TYPE set1
set
127.0.0.1:6379> TYPE set2
set

```

#### 2.4.3.2: 追加数值

```
追加的时候不能追加已经存在的数值
127.0.0.1:6379> SADD set1 v2 v3 v4
(integer) 3
127.0.0.1:6379> SADD set1 v2
(integer) 0
127.0.0.1:6379> TYPE set1
set
127.0.0.1:6379> TYPE set2
set
```

#### 2.4.3.3：查看集合的所有数据

```
127.0.0.1:6379> SMEMBERS set1
1) "v2"
2) "v3"
3) "v4"
4) "v1"
127.0.0.1:6379> SMEMBERS set2
1) "v2"
2) "v4"

```

#### 2.4.3.4：获取集合的差集

差集：已属于A而不属于B的元素成为A与B的差集

```
127.0.0.1:6379> SDIFF set1 set2
1) "v3"
2) "v1"
```

#### 2.4.3.5：获取集合的交集

交集：已属于A且属于B的元素称为A与B的交集

```
127.0.0.1:6379> SINTER set1 set2
1) "v2"
2) "v4"
```

#### 2.4.3.6：获取集合的并集

并集：已属于A或属于B的元素为称为A与B的并集

```
127.0.0.1:6379> SUNION set1 set2
1) "v3"
2) "v1"
3) "v4"
4) "v2"
```

### 2.4.4：sorted set(有序集合)

Redis有序集合和集合一样也是string类型元素的集合，且不允许重复的成员，不同的每个元素都会关联一个double(双精度浮点型)类型的分数，redis正式通过该分数来为集合中的成员进程从小到大的排序，有序集合的成员是唯一的，但分数（score）却可以重复，集合是通过哈希表实现的，所以添加、删除，查找的复杂度都是0（1），集合中最大的成员数为2^32-1(4294967295，每个集合可存储40多亿个成员)

#### 2.4.4.1：生成有序集合

```
127.0.0.1:6379> ZADD zset1 1 v1
(integer) 1
127.0.0.1:6379> ZADD zset1 2 v2
(integer) 1
127.0.0.1:6379> ZADD zset1 2 v3
(integer) 1
127.0.0.1:6379> ZADD zset1 3 v4
(integer) 1
127.0.0.1:6379> TYPE zset1
zset


一次生成多个数据：
127.0.0.1:6379> ZADD zset2 1 v1 2 v2 3 v3 4 v4
(integer) 4

```

#### 2.4.4.2：集合排行案例：

```
127.0.0.1:6379> ZADD paihangbang 90 nezha 199 zhanlang 60 zhuluoji 30 gangtiexie
(integer) 4
127.0.0.1:6379> ZRANGE paihangbang 0 -1 #显示集合内所有的key
1) "gangtiexie"
2) "zhuluoji"
3) "nezha"
4) "zhanlang"

127.0.0.1:6379> ZREVRANGE paihangbang 0 -1 withscores #显示指定集合内所有key和得分情况
1) "zhanlang"
2) "199"
3) "nezha"
4) "90"
5) "zhuluoji"
6) "60"
7) "gangtiexie"
8) "30"

```



#### 2.4.4.3：获取集合的长度数

```
127.0.0.1:6379> ZCARD zset1
(integer) 4
127.0.0.1:6379> ZCARD zset2
(integer) 4
```



#### 2.4.4.4：基于索引返回数值：

```
127.0.0.1:6379> ZRANGE zset1 1 3
1) "v2"
2) "v3"
3) "v4"
127.0.0.1:6379> ZRANGE zset1 0 2
1) "v1"
2) "v2"
3) "v3"
127.0.0.1:6379> ZRANGE zset2 2 2
1) "v3"
```

#### 2.4.4.5：返回某个数值的索引

```
127.0.0.1:6379> ZRANK zset1 v2
(integer) 1
127.0.0.1:6379> ZRANK zset1 v3
(integer) 2

```



### 2.4.5：哈希（hash）

hash是一个string类型的field和value的映射表，hash特别适合用于存储对象，Redis中每个hash可以存储2^32-1键值对（40多亿）

#### 2.4.5.1：生成hash key

```
127.0.0.1:6379> HSET hash1 name tom age 18
(integer) 2
127.0.0.1:6379> TYPE hash1
hash

```



#### 2.4.5.2: 获取hash key字段值

```
127.0.0.1:6379> HGET hash1 name
"tom"
127.0.0.1:6379> HGET hash1 age
"18"

```



#### 2.4.5.3：删除一个hash key的字段

```
127.0.0.1:6379> HDEL hash1 age
(integer) 1

```

#### 2.4.5.4：获取所有hash表中的key

```
127.0.0.1:6379> HMSET hash1 name tom age 19
OK
127.0.0.1:6379> HKEYS hash1
1) "name"
2) "age"

```

#### 2.4.5.5：获取指定hash的所有key及value

```
127.0.0.1:6379> HGETALL hash1
1) "name"
2) "tom"
3) "age"
4) "19"

```

## 2.5：Redis常用命令

### 2.5.1：CONFIG

config命令用于查看当前redis配置，以及不重启更改redis配置等

#### 2.5.1.1：更改最大内存

```
127.0.0.1:6379> CONFIG set  maxmemory 200000
OK
127.0.0.1:6379> CONFIG get maxmemory
1) "maxmemory"
2) "200000"
```

#### 2.5.1.2：设置连接密码：

```
127.0.0.1:6379> CONFIG SET requirepass 123456
OK
127.0.0.1:6379> CONFIG get requirepass
(error) NOAUTH Authentication required.
127.0.0.1:6379> AUTH 123456
OK
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) "123456"

```



#### 2.5.1.3：获取当前配置

```
127.0.0.1:6379> CONFIG GET *

```



### 2.5.2: info:

显示当前节点redis运行状态信息

![](/images/posts/06_redis/00/10.png)



### 2.5.3：SELECT

切换数据库，等于MySQL的use DBNAME指令

```
127.0.0.1:6379> SELECT 1
OK
127.0.0.1:6379[1]> 
```

### 2.5.4：keys

查看当前库下的所有key

```
127.0.0.1:6379> KEYS *
1) "zset2"
2) "hash1"
3) "paihangbang"
4) "zset1"

```

### 2.5.5: BGSAVE

手动在后台执行RDB持久化操作

```
127.0.0.1:6379> BGSAVE
Background saving started

```

### 2.5.6：DBSIZE

返回当前库下的所有key数量

```
127.0.0.1:6379> DBSIZE
(integer) 4

```

### 2.5.7：FLUSHDB

强制清空当前库中的所有key

### 2.5.8: FLUSHALL

强制清空当前redis服务器所有数据库中的所有Key，既删除所有数据

# 三：redis高可用与集群

虽然Redis可以实现单机的数据持久化，但无论是RDB也好或者AOF也好，都解决不了单点冗机问题，既一旦单台redis服务器本身出现相同故障、硬件故障等问题，就会之间造成数据的丢失，因此需要使用另外的技术来解决单点问题

## 3.1：配置redis主从

主备模式，可以实现Redis数据的跨主机备份

程序端连接到高可用负责VIP，然后连接到负载服务器设置的Redis后端real server，此模式不需要在程序里面配置Redis服务器的真实IP地址，当后期Redis服务器IP地址发生变更只需要更改redis相应后端real server即可，可避免更改程序中的IP地址设置











### 3.1.1：Slave主要配置

Redis Slave也要开启持久化并设置和master同样的连接密码，因为后期slave会有提升master的可能，slave端切换master同步后会丢失之前的所有数据

一旦某个slave称为一个master的slave，Redis slave服务会清空当前redis服务器上的所有数据并将master的数据导入到自己的内存，但是断开同步关系后不会删除当前已经同步过的数据

#### 3.1.1.1：命令行配置

当前状态为master，需要转换为slave角色并指向master服务器的IP+PORT+Password

```
127.0.0.1:6379> REPLICAOF 192.168.48.164 6379
OK


127.0.0.1:6379> CONFIG SET masterauth 123456
OK

```

#### 3.1.1.2: 同步日志



![](/images/posts/06_redis/00/11.png)



#### 3.1.1.3：当前slave状态



![](/images/posts/06_redis/00/12.png)



#### 3.1.1.4：保存配置到redis.conf

```
 replicaof 192.168.48.164 6379
 masterauth 123456  #master如果密码需要设置

```



#### 3.1.1.5：重启slave验证



![](/images/posts/06_redis/00/13.png)



#### 3.1.1.6：验证slave数据



```
127.0.0.1:6379> KEYS *
1) "k1"
2) "k2"

```



#### 3.1.1.7：slave状态只读无法写入数据

![](/images/posts/06_redis/00/14.png)



#### 3.1.1.8: 主从复制过程

Redis支持主从复制分为全量同步和增量同步，首次同步时全量同步，主从同步可以让从服务器从主服务器备份数据，而且从服务器还可以与从服务器，既另外一台redis服务器可以从一台从服务器进行数据同步，redis的主从同步时非阻塞，master收到从服务器的sync(2.8版本之前是PSYNC)命令会fork一个子进程在后台执行bgsave命令，并将新写入的数据写入到一个缓冲区里面，bgsave执行完成之后生成的将RDB文件发送给客户端，客户端将收到后的RDB文件载入自己的内存，然后redis master再将缓冲区的内容在全部发送给redis slave，之后的同步slave服务器会发送一个offset的位置（等同于MySQL的binlog得位置）给主服务器，主服务器检查后位置没有错误将此位置之后得数据包括写在缓冲区得积压数据发送给redis从服务器。从服务器将主服务器发送得导入数据写入内存，这样一次完整得数据同步，在之后在同步得时候从服务器只要发送当前得offset位置给主服务器，然后主服务器根据相应位置将之后得数据发送给从服务器保存到其内存即可



Redis全量复制一般发生在slave首次初始化阶段，这时slave需要将Master上得所有数据都复制一份，具体主从同步骤如下：

```
1.从服务器连接主服务器，发送SYNC命令
2.主服务器接收到SYNC命令后，开始执行BGSAVE命令生成RDB快照文件并使用缓冲区记录此后执行得所有写命令
3.主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行得命令
4.从服务器收到快照文件后丢弃所有旧数据，载入收到的快照
5.主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令
6.从服务器完成对快照的载入，开始接受命令请求，并执行来自主服务器缓冲区的写命令
7.后期同步发送自己slave_repl_offset位置，只同步新增加的数据，不在全量同步
```



![](/images/posts/06_redis/00/15.png)



#### 3.1.1.9：主从同步优化

repl-diskless-sync no #是否使用无盘同步RDB文件，默认为no，no为不使用无盘，需要将RDB文件保存到磁盘后在发送给slave，yes为支持无盘，支持无盘就是RDB文件不需要保存至本地磁盘，而且直接通过socket文件发送给slave，repl-diskless-sync-delay 5 #master准备好RDB文件后等待传输时间

repl-ping-slave-period 10 #slave端向server端发送ping的时间区间设置，默认为10秒  repl-timeout 60 #设置超时时间

repl-disable-tcp-nodelay no #是否启用TCP_NODELAY 如设置为yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致，假如设置成no，则redis master会立即发送同步数据，没有延迟，前者关注性能，后者关注redis服务中的数据一致性

repl-backlog-size 1mb #master的写入数据缓冲区，用于记录自上一次同步后到下一次同步过程中间的写入命令，计算公式：repl-backlog-size = 允许从节点中最大中断时长*主实例offset每秒写入量，比如master每秒最大写入64mb,最大允许60秒，那么就要设置为64mb*  * 60秒=3840MB（3.8G）



repl-backlog-ttl 3600 #如果一段时间后没有slave连接到master，则backlog size的内存将会被释放，如果值为0则表示永远不释放这部分内存，slave-priority 100 #slave端的优先级设置一个整数，数字越小表示优先级越高，当master故障时将会按照优先级来选择slave端进行恢复，如果值设置为0，则表示该slave永远不会被选择

min-slaves-to-write 1 #设置一个master端的可用slave少于多少个 #min-slaves-max-lag 20 #设置所有slave延迟时间都大于多少秒时，master不接收写操作（拒绝写入）

#### 

#### 3.1.1.10：slave同步过程日志



![](/images/posts/06_redis/00/16.png)



#### 3.1.1.11：master同步日志



![](/images/posts/06_redis/00/17.png)



#### 3.1.1.12：slave切换master

Master的切换导致master_replid发生变化，slave之前的master_replid就和当前master不一致从而引发所有slave的全量同步

```
127.0.0.1:6379> info replication
# Replication
role:slave
master_host:192.168.48.163
master_port:6379
master_link_status:up
master_last_io_seconds_ago:3#最近一次与master通信已经过去多少秒
master_sync_in_progress:0 #是否正在与master通信
slave_repl_offset:574 #当前同步的偏移量
slave_priority:100 #slave优先级，master故障后值越小优先同步
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:5b83eae5a4c3fb282963df316413f2198dc2f2c1
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:574
second_repl_offset:-1
repl_backlog_active:1


```

停止slave同步并查看当前状态

```
127.0.0.1:6379> info Replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:018010214d5d02bc7e43d3d38a92f8fb8217b119
master_replid2:5b83eae5a4c3fb282963df316413f2198dc2f2c1
master_repl_offset:630
second_repl_offset:631
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:183
repl_backlog_histlen:448

```

测试能否写入数据

```
127.0.0.1:6379> set key1 values1
OK

```

## 3.2：redis集群：

上一个步骤的主从架构无法实现master和slave角色的自动切换，既当master出现redis服务异常、主机断电、磁盘损坏等问题导致master无法使用，而redis高可用实现自动故障转移（将slave提升为master），需要手动改环境配置才能切换到slave redis服务器，另外也无法横向扩展redis服务的并行写入性能，单台redis服务器性能无法满足业务写入需求的时候必须需要一种方式解决以上的两个核心问题，既：1master和lsave角色的无缝切换，让业务无感知从而不影响业务使用2.可用横向动态扩展Redis服务器，从而实现多台服务器并行写入以实现更高并发的目的

```
Redis 集群实现方式：客户端分片 代理分片 Redis cluster
```

### 3.2.1: Sentinel(哨兵)：

Sentinel进程是用于监控redis集群中Master主服务器工作的状态，在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用，其已经被集成在redis2.6+的版本中，Redis的哨兵模式到了2.8版本之后就稳定了下来，一般在生产环境也建议使用Redis的2.8版本的以后版本。哨兵（sentinel）是一个分布式系统，可以在一个架构中运行多个哨兵（Sentinel）进程，这些进程使用流言协议（gossip protocols）来接收关于Master主服务器是否下线的信息，并使用投票协议（Agreement Protocols）来决定是否执行自动故障迁移，以及选择哪个slave作为新的Master，每个哨兵（Sentinel）进程会向其它哨兵（Sentinel）进程会向其它哨兵（Sentinel）、Master、Slave定时发送信息，以确认对方是否活着，如果发现对方在指定配置时间（可配置）的内未得到回应，则暂时认为对方已掉线，也就是所谓的主观认为冗机，主观是每个成员都具有的独自的而且可能相同也可能不同的意识，英文名称：Subjective Down,简称SDOWN，有主观冗机，肯定就有客观冗机，当哨兵群中的多数sentinel进程在对master主服务器做出SDOWN的判断，并且通过SENTINEL is-,aster-down-by-addr命令互相交流之后，得出的Master Server下线判断，这种方式就是客观冗机，客观是不依赖于某种意识而已经实际存在的一切事务，英文名称是：Objecticely Down，简称ODOWN，通过一定的vote算法，从剩下的slave从服务器节点中，选一台提升为Master服务器节点，然后自动修改相关配置，并开启故障转移（failover）

Sentinel机制可以解决master和slave角色的切换问题



#### 3.2.1.1：手动配置master

需要手动指定某一台Redis服务器为master，然后将其它slave服务器使用命令配置为master服务器的slave，哨兵的前提时已经手动实现了一个redis master-slave的运行环境

实现一个一主两从基于哨兵的高可用redis架构



##### 3.2.1.1.1：服务器A配置slave

```
127.0.0.1:6379> REPLICAOF 192.168.48.163 6379
OK
127.0.0.1:6379> CONFIG SET masterauth "123456"
OK

```

![](/images/posts/06_redis/00/18.png)

##### 3.2.1.1.2：服务器B配置slave

```
127.0.0.1:6379> REPLICAOF 192.168.48.163 6379
OK
127.0.0.1:6379> CONFIG SET masterauth "123456"
OK

```

![](/images/posts/06_redis/00/19.png)



##### 3.2.1.1.3: 当前master状态



![](/images/posts/06_redis/00/20.png)



##### 3.2.1.1.4：应用程序如何连接redis

Redis 官方客户端：https://redis.io/clients

java客户端连接redis是通过Jedis来实现的，java代码用的时候只要创建Jedis对象就可以建多个Jedis连接池来连接redis，应用程序在直接调用连接池即可连接Redis

而Redis为了保障高可用，服务一般都是Sentinel部署方式，当Redis服务中的主服务挂掉之后，会仲裁出另外一台Slave服务充当Master，这个时候，我们的应用即使使用了Jedis连接池，Master服务挂了，我们的应用将还是无法连接新的Master服务，为了解决这个问题，Jedis也提供了相应的Sentinel实现，能够在Redis Sentinel主从切换时候，通知我们的应用，把我们的应用连接到新的Master服务

Redis Sentinel的使用也是十分简单的，只是在JedisPool中添加了Sentinel和MasterName参数，JRedis Sentinel底层基于Redis订阅实现Redis主从服务的切换通知，当Redis发生主从切换时，Sentinel会发送通知主动通知Jedis进行连接的切换，JedisSentinelPool在每次从连接池中获取链接对象的时候，都要对连接进程检测，如果此链接和Sentinel的Master服务连接参数不一致，则会关闭此连接，重新获取新的Jedis连接对象



##### 3.2.1.1.5: pythin连接redis

```
#apt install python-pip
#pip install redis
root@redis:~# cat test.py 
#!/bin/env python
import redis
pool = redis.ConnectionPool(host="192.168.48.163", port=6379,password='123456')
r = redis.Redis(connection_pool=pool)
for i in range(50):
    r.set("k%d" %i,"v%d" %i)
    data=r.get("k%d" %i)
    print(data)

```

##### 3.2.1.1.6: 各redis服务器验证数据

![](/images/posts/06_redis/00/21.png)



#### 3.3.1.1：编辑配置文件sentinel.conf

##### 3.3.1.1.1: Server1配置

哨兵可以不和Redis服务器部署在一起

```
root@redis:/apps/redis/etc# cat sentinel.conf 
bind 0.0.0.0
port 26379
daemonize yes
pidfile redis-sentinel.pid
logfile "sentinel_26379.log"
dir "/apps/redis-sentinel"
sentinel monitor mymaster 192.168.48.163 6379 2
sentinel auth-pass mymaster 123456
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes

```

##### 3.3.1.1.2: server2配置

```
root@redis:/apps/redis/etc# cat sentinel.conf 
bind 0.0.0.0
port 26379
daemonize yes
pidfile redis-sentinel.pid
logfile "sentinel_26379.log"
dir "/apps/redis-sentinel"
sentinel monitor mymaster 192.168.48.163 6379 2
sentinel auth-pass mymaster 123456
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes

```



##### 3.3.1.1.3： server3配置

```
root@redis:/apps/redis/etc# cat sentinel.conf 
bind 0.0.0.0
port 26379
daemonize yes
pidfile redis-sentinel.pid
logfile "sentinel_26379.log"
dir "/apps/redis-sentinel"
sentinel monitor mymaster 192.168.48.163 6379 2
sentinel auth-pass mymaster 123456
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel deny-scripts-reconfig yes
```

#### 3.3.1.2: 启动哨兵

三台哨兵都要启动

```
#/apps/redis/bin/redis-sentinel /apps/redis/etc/sentinel.conf
#/apps/redis/bin/redis-sentinel /apps/redis/etc/sentinel.conf
#/apps/redis/bin/redis-sentinel /apps/redis/etc/sentinel.conf
```

#### 3.3.1.3：验证哨兵端口

![](/images/posts/06_redis/00/22.png)



#### 3.3.1.4：哨兵日志

![](/images/posts/06_redis/00/23.png)

#### 3.3.1.5：当前redis master状态

```
127.0.0.1:6379> info Replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.48.166,port=6379,state=online,offset=71435,lag=1
slave1:ip=192.168.48.164,port=6379,state=online,offset=71435,lag=1
master_failover_state:no-failover
master_replid:5b83eae5a4c3fb282963df316413f2198dc2f2c1
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:71435
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:71435

```

#### 3.3.1.6：当前sentinel状态

在sentinel状态中尤其最后一行，涉及到masterIP是多少，有几个slave,有几个sentinels，必须是符合全部服务器数量

```
root@redis:/apps/redis/etc# redis-cli -p 26379
127.0.0.1:26379> info Sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=192.168.48.163:6379,slaves=2,sentinels=3

```

#### 3.3.1.7: 停止Redis Master测试故障转移

```
systemctl stop redis
```

故障转移时sentinel的信息



![](/images/posts/06_redis/00/24.png)

#### 3.3.1.8：故障转移后的redis配置文件

故障转移后redis.conf中的replicaof行的masterIP会被修改，sentinel.conf中的sentinel monitor IP会被修改

![](/images/posts/06_redis/00/25.png)



#### 3.3.1.9：当前redis状态



![](/images/posts/06_redis/00/26.png)



### 3.2.2: Redis Cluster

在哨兵sentinel机制中，可以解决redis高可用的问题，既当master故障后可以自动将slave提升为master从而可以保证redis服务的正常使用，但是无法解决redis单机写入的瓶颈问题，既单机的redis写入性能受限于单机的内存大小、并发数量、网卡速率等因素，因此redis官方在redis3.0版本之后推出了无中心架构的redis cluster机制，在无中心的redis集群当中，其每个节点保存当前节点数据和整个集群状态，内阁节点都和其它所有节点连接，特点如下

```
1.所有redis节点使用（PING机制）互联
2.集群中某个节点的失效，是整个集群中超过半数的节点检测都失效才算真正的失效
3.客户端不需要proxy既可直接连接redis,应用程序需要写全部的redis服务器IP
4.redis cluster把所有的redis node映射到0-16383个槽位（slot）上，读写需要到指定的redis node上进行操作，因此有多少个redis node相当于redis 并发扩展了多少倍
5.redis cluster预先分配16383个(slot)槽位，当需要在redis集群中写入一个key -valude的时候，会使用CRC16（key）mod 163834之后的值，决定将key写入值哪一个槽位从而决定写入哪一个redis节点上，从而有效解决单个瓶颈
```



#### 3.2.2.1：Redis cluster架构

##### 3.2.2.1.1：Redis cluster基本架构

假如三个主节点分别是：A,B,C三个节点，采用哈希槽（hash slot）的方式分配16384个slot的话，他们三个节点分别承担的slot区别是：

```
节点A覆盖0-5460
节点B覆盖5461-10922
节点C覆盖10923-16383
```



![](/images/posts/06_redis/00/27.png)



##### 3.2.2.1.2：Redis cluster主从架构：

Redis cluster的架构虽然解决了并发的问题，但是又引入了一个新的问题，每个Redis master的高可用如何解决



![](/images/posts/06_redis/00/28.png)



#### 3.2.2.2：部署redis集群：

环境准备

| 192.168.48.147 | 192.168.48.147 |
| -------------- | -------------- |
| 192.168.48.163 | 192.168.48.164 |
| 192.168.48.165 | 192.168.48.166 |



##### 3.2.2.2.1:创建redis cluster集群的前提：

1.每个redis node节点采用相同的硬件配置、相同的密码、相同的redis版本

2.每个节点必须开启的参数cluster-enable yes #必须开启集群状态，开启后redis进程会有cluster显示cluster-config-file nodes-6380.conf #此文件有redis cluster集群自动创建和维护，不需要任何手动操作

3.所有redis服务器必须没有任何数据

4.先启动为单机redis且没有任何key value

![](/images/posts/06_redis/00/29.png)

验证当前Redis服务状态：



![](/images/posts/06_redis/00/30.png)



##### 3.2.2.2.2：创建集群：

帮助命令

```
root@s1:/apps/redis# redis-cli --cluster help
Cluster Manager Commands:
  create         host1:port1 ... hostN:portN #创建集群
                 --cluster-replicas <arg> #指定master的副本数量
  check          host:port #检查集群信息
                 --cluster-search-multiple-owners
  info           host:port #查看集群主机信息
  fix            host:port #修复集群
                 --cluster-search-multiple-owners
                 --cluster-fix-with-unreachable-masters
  reshard        host:port #在线热迁移集群指定主机的slots数据
                 --cluster-from <arg>
                 --cluster-to <arg>
                 --cluster-slots <arg>
                 --cluster-yes
                 --cluster-timeout <arg>
                 --cluster-pipeline <arg>
                 --cluster-replace
  rebalance      host:port	#平衡集群中各主机的slot数量
                 --cluster-weight <node1=w1...nodeN=wN>
                 --cluster-use-empty-masters
                 --cluster-timeout <arg>
                 --cluster-simulate
                 --cluster-pipeline <arg>
                 --cluster-threshold <arg>
                 --cluster-replace
  add-node       new_host:new_port existing_host:existing_port #添加主机到集群
                 --cluster-slave
                 --cluster-master-id <arg>
  del-node       host:port node_id #删除主机
  call           host:port command arg arg .. arg #在集群上的所有节点上执行命令
                 --cluster-only-masters
                 --cluster-only-replicas
  set-timeout    host:port milliseconds #设置节点的超时时间
  import         host:port #导入外部redis服务器的数据到集群
                 --cluster-from <arg>
                 --cluster-from-user <arg>
                 --cluster-from-pass <arg>
                 --cluster-from-askpass
                 --cluster-copy
                 --cluster-replace
  backup         host:port backup_directory
  help           

For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.

Cluster Manager Options:
  --cluster-yes  Automatic yes to cluster commands prompts


```



```
root@s1:/apps/redis# redis-cli -a 123456 --cluster create 192.168.48.161:6379 192.168.48.162:6379 192.168.48.163:6379 192.168.48.164:6379 192.168.48.165:6379 192.168.48.166:6379 --cluster-replicas 1
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 192.168.48.165:6379 to 192.168.48.161:6379
Adding replica 192.168.48.166:6379 to 192.168.48.162:6379
Adding replica 192.168.48.164:6379 to 192.168.48.163:6379
M: e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379 #带M的为master
   slots:[0-5460] (5461 slots) master#当前master的槽位起始和结束位
M: fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379
   slots:[5461-10922] (5462 slots) master#当前master的槽位起始和结束位
M: 789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379
   slots:[10923-16383] (5461 slots) master #当前master的槽位起始和结束位
S: 94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379
   replicates 789b29f2ed733b1cd61658b865a841bc7126e034
S: 5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379
   replicates e945256182c021142d3fe421aa0d157f68877528
S: 282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379
   replicates fa7dc41e87d0e553cb4b98ec85562514414732ef
Can I set the above configuration? (type 'yes' to accept): yes #输入yes自动创建集群
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join

>>> Performing Cluster Check (using node 192.168.48.161:6379)
M: e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379 #MASTER的IP及端口
   slots:[0-5460] (5461 slots) master #已经分配的槽位
   1 additional replica(s)	#分配了一个slave
M: 789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379
   slots:[10923-16383] (5461 slots) master #已经分配的槽位
   1 additional replica(s) #分配了一个slave
S: 282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379
   slots: (0 slots) slave #slave没有分配槽位
   replicates fa7dc41e87d0e553cb4b98ec85562514414732ef
S: 5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379
   slots: (0 slots) slave
   replicates e945256182c021142d3fe421aa0d157f68877528
S: 94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379
   slots: (0 slots) slave
   replicates 789b29f2ed733b1cd61658b865a841bc7126e034
M: fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379
   slots:[5461-10922] (5462 slots) master  #已经分配的槽位
   1 additional replica(s) #分配了一个slave
[OK] All nodes agree about slots configuration.
>>> Check for open slots...	#检查打开的槽位
>>> Check slots coverage...	#检查插槽范围
[OK] All 16384 slots covered. #所有槽位（16384个）分配完成

```

##### 3.2.2.2.3：验证Redis集群状态

由于未设置masterauth认证密码，所以主从为建立起来，但是集群已经运行。所以需要在每个slave控制器台使用config set设置masterauth密码，或者写在每个redis配置文件中，最好是在控制点设置密码之后在写入配置文件中



![](/images/posts/06_redis/00/31.png)



##### 3.2.2.2.4: 分别设置masterauth密码：

```
root@s1:~# redis-cli -h 192.168.48.164 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.164:6379> CONFIG SET masterauth 123456
OK

root@s1:~# redis-cli -h 192.168.48.165 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.165:6379> CONFIG SET masterauth 123456
OK


root@s1:~# redis-cli -h 192.168.48.166 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.166:6379> CONFIG SET masterauth 123456
OK
```



##### 3.2.2.2.5：确认slave状态未up

![](/images/posts/06_redis/00/32.png)



##### 3.2.2.2.6: 验证master状态

![](/images/posts/06_redis/00/33.png)



##### 3.2.2.2.7: 验证集群状态

```
127.0.0.1:6379> CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:8937
cluster_stats_messages_pong_sent:8642
cluster_stats_messages_fail_sent:5
cluster_stats_messages_sent:17584
cluster_stats_messages_ping_received:8637
cluster_stats_messages_pong_received:8935
cluster_stats_messages_meet_received:5
cluster_stats_messages_fail_received:1
cluster_stats_messages_received:17578

```

##### 3.2.2.2.8：查看集群node对应关系

```
127.0.0.1:6379> CLUSTER nodes
789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379@16379 master - 0 1652100174000 3 connected 10923-16383
282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379@16379 slave fa7dc41e87d0e553cb4b98ec85562514414732ef 0 1652100173000 2 connected
5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379@16379 slave e945256182c021142d3fe421aa0d157f68877528 0 1652100176255 1 connected
94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379@16379 slave 789b29f2ed733b1cd61658b865a841bc7126e034 0 1652100174229 3 connected
fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379@16379 master - 0 1652100175241 2 connected 5461-10922
e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379@16379 myself,master - 0 1652100171000 1 connected 0-5460

```

##### 3.2.2.2.9：集群状态验证于监控

```
root@s1:~# redis-cli -a 123456 --cluster check 192.168.48.161:6379
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.161:6379 (e9452561...) -> 0 keys | 5461 slots | 1 slaves.
192.168.48.163:6379 (789b29f2...) -> 0 keys | 5461 slots | 1 slaves.
192.168.48.162:6379 (fa7dc41e...) -> 0 keys | 5462 slots | 1 slaves.
[OK] 0 keys in 3 masters.
0.00 keys per slot on average.
>>> Performing Cluster Check (using node 192.168.48.161:6379)
M: e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
M: 789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
S: 282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379
   slots: (0 slots) slave
   replicates fa7dc41e87d0e553cb4b98ec85562514414732ef
S: 5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379
   slots: (0 slots) slave
   replicates e945256182c021142d3fe421aa0d157f68877528
S: 94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379
   slots: (0 slots) slave
   replicates 789b29f2ed733b1cd61658b865a841bc7126e034
M: fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.

root@s1:~# redis-cli -a 123456 --cluster info 192.168.48.166:6379
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.161:6379 (e9452561...) -> 0 keys | 5461 slots | 1 slaves.
192.168.48.163:6379 (789b29f2...) -> 0 keys | 5461 slots | 1 slaves.
192.168.48.162:6379 (fa7dc41e...) -> 1 keys | 5462 slots | 1 slaves.
[OK] 1 keys in 3 masters.
0.00 keys per slot on average.


```

##### 3.2.2.2.10：验证集群写入key

```
127.0.0.1:6379> SET key1 value1 #经过算法计算，当前key的槽位需要写入指定的node
(error) MOVED 9189 192.168.48.162:6379 #槽位不在当前Node所以无法写入

192.168.48.162:6379> SET key1 value1 #指定的node就可以写入
OK
192.168.48.162:6379> KEYS *
1) "key1"
127.0.0.1:6379> KEYS *
(empty array)
```



### 3.2.3：Redis cluster集群节点维护

集群运行时间长久之后，难免由于硬件故障、网络规划、业务增长等原因对已有集群进行相应的调整，比如增加Redis node节点、减少节点、节点迁移、更换服务器等



```
增加节点和删除节点会涉及到已有的槽位重新分配及数据迁移
```

#### 3.2.3.1：集群维护之动态添加节点

增加Redis node节点，需要于之前的Redis node版本相同、配置一致，然后分别启动两台 redis node，因为一主一从

案例：

因公司业务发展迅猛，现有的三主三从redis cluster架构可能无法满足现有业务的并发写入需求，因此公司紧急采购一台服务器192.168.48.167,需要将其动态添加到集群当中其不能影响业务使用和数据丢失，则添加过程如下

同步之前Redis node的配置文件到192.168.48.167 Redis编译安装目录，注意配置文件的监听IP

```
#scp redis.conf 192.168.48.167:/apps/redis/etc/
#scp nodes-6379.conf 192.168.48.167:/apps/redis/etc/
```

分别启动redis服务：

```
#systemctl daemon-reload
# systemctl restart redis
#/apps/redis/etc/redis-server /apps/redis/etc/nodes-6379.conf
```

##### 3.2.3.1.1: 添加节点到集群

```
add-node	new_host:new_port	existing_host:existing_port
要添加的新redis节点IP和端口	添加到集群中的master ip:端口，新的node节点到集群之后默认是master节点，但是没有slots数据，需要重新分配
```

添加方式

```
root@s1:/apps/redis/data# redis-cli -a 123456 --cluster add-node 192.168.48.167:6379 192.168.48.161:6379
```

![](/images/posts/06_redis/00/34.png)



##### 3.2.3.1.2：重新分配槽位

添加主机之后需要对添加至集群中的新主机重新分片否则其没有分片也就无法写入数据

验证当前状态

![](/images/posts/06_redis/00/35.png)

使用命令对新加的主机重新分配槽位

```
root@s1:/apps/redis/data# redis-cli -a 123456 --cluster reshard 192.168.48.167:6379
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
>>> Performing Cluster Check (using node 192.168.48.167:6379)
M: 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e 192.168.48.167:6379
   slots:[0 slots] master
M: 789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379
   slots:[12288-16383] (4096 slots) master
   1 additional replica(s)
M: e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379
   slots:[1365-5460] (4096 slots) master
   1 additional replica(s)
M: fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379
   slots:[6827-10922] (4096 slots) master
   1 additional replica(s)
S: 94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379
   slots: (0 slots) slave
   replicates 789b29f2ed733b1cd61658b865a841bc7126e034
S: 5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379
   slots: (0 slots) slave
   replicates e945256182c021142d3fe421aa0d157f68877528
S: 282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379
   slots: (0 slots) slave
   replicates fa7dc41e87d0e553cb4b98ec85562514414732ef
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 4096 #分配多少槽位
What is the receiving node ID? 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e #接收slot的服务器ID，输入192.168.48.167的node ID
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1: all #将哪些源主机的槽位分配给192.168.48.167:6379,all是自动在所有的redis node选择划分，如果是从redis cluster删除主机可以使用此方式将主机上的槽位全部移动到别的redis主机
...............................
  Moving slot 8178 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8179 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8180 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8181 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8182 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8183 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8184 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8185 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8186 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8187 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8188 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8189 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8190 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    Moving slot 8191 from fa7dc41e87d0e553cb4b98ec85562514414732ef
    ......................................
Do you want to proceed with the proposed reshard plan (yes/no)? yes #确认分配

```



![](/images/posts/06_redis/00/36.png)

3.2.3.1.3：验证重新分配槽位之后的集群状态

![](/images/posts/06_redis/00/37.png)



##### 3.2.3.1.4: 为新的master添加slave节点

需要在像当前redis集群中添加一个Redis单机服务器，用于解决当前192.168.48.167单机的潜在冗机问题，既实现相应的高可用功能

把192.168.48.168添加到集群中

```
root@s1:/apps/redis/data# redis-cli -a 123456 --cluster add-node 192.168.48.168:6379 192.168.48.161:6379
```

![](/images/posts/06_redis/00/38.png)



##### 3.2.3.1.5: 更改新节点更改状态为slave

需要手动将其指定某个master的slave，否则其默认角色为master

```
root@s1:/apps/redis/data# redis-cli -h 192.168.48.168 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.168:6379> CLUSTER NODES #查看当前集群节点，找到目标master的ID
5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379@16379 slave e945256182c021142d3fe421aa0d157f68877528 0 1652107113000 1 connected
fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379@16379 master - 0 1652107116255 2 connected 6827-10922
56e2dd145d91935500260253497da9df16358ae1 192.168.48.168:6379@16379 myself,master - 0 1652107115000 0 connected
e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379@16379 master - 0 1652107117267 1 connected 1365-5460
94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379@16379 slave 789b29f2ed733b1cd61658b865a841bc7126e034 0 1652107114236 3 connected
8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e 192.168.48.167:6379@16379 master - 0 1652107115000 7 connected 0-1364 5461-6826 10923-12287
282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379@16379 slave fa7dc41e87d0e553cb4b98ec85562514414732ef 0 1652107113000 2 connected
789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379@16379 master - 0 1652107114000 3 connected 12288-16383
192.168.48.168:6379> CLUSTER REPLICATE 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e #将其设置slave 命令格式为cluster replicate masterid
OK


192.168.48.168:6379> CLUSTER NODES #再次查看集群节点状态，验证节点是否已经更改为指定master的slave
5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379@16379 slave e945256182c021142d3fe421aa0d157f68877528 0 1652107214168 1 connected
fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379@16379 master - 0 1652107216000 2 connected 6827-10922
56e2dd145d91935500260253497da9df16358ae1 192.168.48.168:6379@16379 myself,slave 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e 0 1652107216000 7 connected
e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379@16379 master - 0 1652107216183 1 connected 1365-5460
94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379@16379 slave 789b29f2ed733b1cd61658b865a841bc7126e034 0 1652107215000 3 connected
8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e 192.168.48.167:6379@16379 master - 0 1652107218200 7 connected 0-1364 5461-6826 10923-12287
282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379@16379 slave fa7dc41e87d0e553cb4b98ec85562514414732ef 0 1652107219208 2 connected
789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379@16379 master - 0 1652107218000 3 connected 12288-16383

```

##### 3.2.3.1.6: 验证当前集群状态

确认每个master都有一个slave



![](/images/posts/06_redis/00/39.png)



#### 3.2.3.2: 集群维护之动态删除节点

添加节点的时候是先添加node节点到集群，然后分配槽位，删除节点的操作与添加节点的操作正好相反，是先将被删除的Redis node上的槽位迁移到集群中的其它redis node节点上，然后在将其删除，如果一个Redis node节点上的槽位没有被完全迁移，删除改node的时候会提示有数据且无法删除

案例：

由于192.168.48.167服务器使用年限已经超过三年，已经超过厂商质保期而且硬盘出现异常报警，经运维部架构师提交方案并同开发同事开会商议，决定将现有Redis集群的4台主服务器分别是192.168.48.161/162/163/167中的167临时下线，三台服务器的并发写入性能足够支出未来1-2年的业务需求，则删除Redis node 192.168.48.167的操作如下：

##### 3.2.3.2.1：迁移master的槽位之其它master

被迁移Rdis master源服务器必须保证没有数据，否则迁移报错并会被强制中断

```
root@s1:~# redis-cli -a 123456 --cluster reshard 192.168.48.161:6379
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
>>> Performing Cluster Check (using node 192.168.48.161:6379)
M: e945256182c021142d3fe421aa0d157f68877528 192.168.48.161:6379
   slots:[1365-5460] (4096 slots) master
   1 additional replica(s)
S: 5d2b39ff6d2de13727e3fec4aceb1cd06b46f978 192.168.48.165:6379
   slots: (0 slots) slave
   replicates e945256182c021142d3fe421aa0d157f68877528
S: 94869fac64164d7a3834f229aff73c17356ed838 192.168.48.164:6379
   slots: (0 slots) slave
   replicates 789b29f2ed733b1cd61658b865a841bc7126e034
M: fa7dc41e87d0e553cb4b98ec85562514414732ef 192.168.48.162:6379
   slots:[6827-10922] (4096 slots) master
   1 additional replica(s)
S: 56e2dd145d91935500260253497da9df16358ae1 192.168.48.168:6379
   slots: (0 slots) slave
   replicates 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
M: 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e 192.168.48.167:6379
   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master
   1 additional replica(s)
M: 789b29f2ed733b1cd61658b865a841bc7126e034 192.168.48.163:6379
   slots:[12288-16383] (4096 slots) master
   1 additional replica(s)
S: 282bb544703906302717c56758a7c9f7dc31dc06 192.168.48.166:6379
   slots: (0 slots) slave
   replicates fa7dc41e87d0e553cb4b98ec85562514414732ef
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 4096#迁移master上的槽位
What is the receiving node ID? e945256182c021142d3fe421aa0d157f68877528 #接收槽位的服务器ID
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1: 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e #从哪个服务器迁移4096槽位
Source node #2: done #写node，表示没有其它master
  Moving slot 12282 from 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
    Moving slot 12283 from 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
    Moving slot 12284 from 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
    Moving slot 12285 from 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
    Moving slot 12286 from 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
    Moving slot 12287 from 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
Do you want to proceed with the proposed reshard plan (yes/no)? yes #是否继续

```

![](/images/posts/06_redis/00/40.png)

迁移完成

##### 3.2.3.2.2：验证槽位迁移完成

![](/images/posts/06_redis/00/41.png)



##### 3.2.3.2.4: 从集群删除服务器

虽然槽位已经迁移完成，但是服务器IP信息还在集群当中，因此还需要将IP信息从集群删除

#删除master

```
root@s1:/apps/redis/logs# redis-cli -a 123456 --cluster del-node 192.168.48.161:6379 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
>>> Removing node 8f7a66ea9ea8f4b8b02e7f3c9722c4c083753a8e from cluster 192.168.48.161:6379
>>> Sending CLUSTER FORGET messages to the cluster...
>>> Sending CLUSTER RESET SOFT to the deleted node.
```

##### 3.2.3.2.5: 验证Node是否删除

验证并确认192.168.48.167：6379已经从redis集群中删除

![](/images/posts/06_redis/00/42.png)



#### 3.2.3.3：集群维护之模拟master冗机

目前架构为三主三从，互为跨主机master slave模式，测试master冗机之后是否会自动切换至slave

##### 3.2.3.3.1: 测试数据写入

测试在master写入数据，并在其对应的slave验证数据

```
192.168.48.162:6379> SET key1 value1
OK
192.168.48.162:6379> get key1
"value1"
```

##### 3.2.3.3.2：slave验证数据

```
192.168.48.166:6379> keys *
1) "key1"
192.168.48.166:6379> get key1
(error) MOVED 9189 192.168.48.162:6379 #slave不提供读写，只提供数据备份既master选举

```

##### 3.2.3.3.3：停止master并验证故障转移

Redis Master服务停止后，其对应的slave会被选举为master继续处理数据的读写操作

```
root@s2:~# systemctl stop redis
```

##### 3.2.3.3.4：验证slave日志

```
#tail -f /apps/redis/logs/redis_6379.log #需要相应的数秒故障转移时间
```

![](/images/posts/06_redis/00/43.png)

##### 3.2.3.3.5：验证slave当前状态

![](/images/posts/06_redis/00/44.png)



##### 3.2.3.3.6：验证数据读写：

确认slave 192.168.48.166:6379切换为master之后可以继续为业务提供读写业务数据没有丢失

```
192.168.48.166:6379> KEYS *
1) "key1"
192.168.48.166:6379> SET key5  values3
OK
192.168.48.166:6379> get key1
"value1"
192.168.48.166:6379> get key5
"values3"
192.168.48.166:6379> 

```

注：服务恢复之后重新验证各master的slave

#### 3.2.3.4：集群维护之导入现有的redis数据：

导入数据需要redis cluster不能与被导入的数据有重复的key名称，否则导入不成功或中断

案例：公司将redis cluster部署完成之后，需要将之前的数据导入之redis cluster集群，但是由于Redis cluster使用的分片保存key的机制，因此使用传统的AOF文件或RDB快照无法满足需求，因此需要使用集群数据导入命令完成

##### 3.2.3.4.1：基础环境准备

导入数据之前需要关闭各redis服务器的密码，包括集群中的各node和源redis server避免认证带来的环境不一致从而无法导入，可以加参数--cluster-replace 强制替换Redis cluster已有的key

关闭各Redis密码认证

```
root@s1:~# redis-cli -h 192.168.48.161 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.161:6379> CONFIG SET requirepass ""
OK
root@s1:~# redis-cli -h 192.168.48.162 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.162:6379> CONFIG SET requirepass ""
OK
root@s1:~# redis-cli -h 192.168.48.163 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.163:6379> CONFIG SET requirepass ""
OK
root@s1:~# redis-cli -h 192.168.48.164 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.164:6379> CONFIG SET requirepass ""
OK
root@s1:~# redis-cli -h 192.168.48.165 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.165:6379> CONFIG SET requirepass ""
OK
root@s1:~# redis-cli -h 192.168.48.166 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
192.168.48.166:6379> CONFIG SET requirepass ""
OK

```

##### 3.2.3.4.2：执行数据导入

将源Redis server的数据直接导入之redis cluster

命令格式：

```
#redis-cli --cluster import 集群服务器IP：PORT --cluster-from 外部redis node-IP：PORT --clusster-copy --cluster-replace
```



![](/images/posts/06_redis/00/45.png)



##### 3.2.3.4.3: Redis cluster验证数据

```
127.0.0.1:6379> KEYS *
1) "key2"
2) "key6"
127.0.0.1:6379> get key2
"value2"
127.0.0.1:6379> get key6
"value3"

```

