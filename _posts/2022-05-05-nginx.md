1.Nginx扩展

https://github.com/agile6v/awesome-nginx #Nginx扩展功能

https://www.digitalocean.com/community/tools/nginx #Nginx在线配置生成器

https://www.runoob.com/lua/lua-tutorial.html #lua教程

# 二： Nginx基础：

Nginx: engine X, 2002年由毕业于俄罗斯国立莫斯科鲍曼科技大学的工程师伊戈尔 西索夫（lgorSysoev)开始开发，2004年开源，2019年3月11日，Nginx公司被F5 Networks以6.7亿美元收购，Nginx 官网： http://nginx.org  Nginx商业版为Nginx Plus: https://www.nginx.com/products/nginx/

![](/images/posts/03_nginx/00/1.png)



Nginx则是免费的、开源的、高性能的HTTP和反向代理服务器、邮件代理服务器、以及TCP/UDP代理服务器

解决C10问题（10K Connections）,http://www.ideawu.net/blog/archives/740.html

nginx的其它二次发行版：

 Tengine: 由淘宝网发起的web服务器项目，它在Nginx的基础上，针对大访问量网站的需求，添加了很多高级功能和特性，Tengine的性能和稳定已经在大型网站如淘宝网，天猫商城等得到了很多的检验，它的最终目标是打造一个高效、稳定、安全、易用的Web平台，从2011年12月开始，Tengine成为一个开源项目，官网http://tengine.taobao.org/



  OpenRestry: 基于Nginx于Lua语言的高性能Web平台，章亦春团队开发，官网： http://openresty.org/cn



## 2.2 Nginx功能介绍：

静态的web资源服务器html，图片，js，css，txt等静态资源

结合FastCGI/uWSGI/SCGI等协议方向代理动态资源请求

http/https协议的方向

imap4/pop3协议的方向代理

tcp/udp等协议的请求转发（转发代理）

### 2.1.1 基础特性：

```
特性：
模块化设计，较好的扩展性
高可靠性
支持热部署：不停机更新配置文件，升级版本，更换日志文件
低内存消耗：10000个keep-alive连接模式下的非活动连接，仅需2.5M内存event-driven.aio.mmap.sendfile

基本功能：
静态资源的web服务器
http协议反向代理服务器
pop3/imap4协议方向代理服务器
FastCGI(LNMP),uWSGI(python)等协议
模块化（非DSO），如zip,SSL模块
```



### 2.1.2 和web服务相关的功能

```
虚拟主机（server）
支持Keep-alive和管道连接（利用一个连接做多次请求）
访问日志（支持基于日志和缓冲提高其性能）
url rewirte
路径别名
基于IP及用户的访问控制
支持速率限制及并发数限制
重新配置和在线升级而无须中断客户的工作进程
```

## 2.2 Nginx组织结构：

web请求处理机制：

1.多进程方式：服务器每接收到一个客户端就有服务器的主进程生成一个子进程响应客户端，直到用户关闭连接，这样的优势是处理速度快，各子进程之间相互独立，但是如果访问过大导致服务器资源耗尽而无法提供请求

2.多进程方式：与多进程方式类似，但是每收到一个客户端请求会有服务器进程派出一个线成来给客户端进程交互，一个线成的开销远远小于一个进程，因此多线程方式在很大程度减轻了web服务器对系统资源的要求，但是多线程也有自己的缺点，既当多个线成位于一个进程内工作的时候，可以相互访问同样的内存地址空间，所以他们相互影响，另外一旦主进程挂掉则所有子线程都不能工作了，IIS服务器使用了多线程的方式，需要间隔一段时间就重启一次才能稳定。

### 2.2.1 组织模型：

Nginx是多线程组织模型，而且一个由Master主进程和Worker工作流程组成



![](/images/posts/03_nginx/00/2.png)

主进程（master process）的功能

```
读取Nginx 配置文件并验证其有效性和正确性
建立、绑定和关闭socker连接
按照配置生成、管理和结束工作进程
接受外部指令，比如重启、升级及退出服务器等指令
不中断服务，实现平滑升级，重启服务并应用新的配置
开启日志文件，获取文件描述符
不中断服务，实现平滑升级，升级失败进行回滚处理
编译和处理perl脚本
```

工作进程（woker process）的功能：

```
接受处理客户的请求
将请求依次送入各个功能模块进行处理
IP调用，获取响应数据
于后端服务器通信，接收后端服务器的处理结果
缓存数据，访问缓存索引，查询和调用缓存数据
发送请求结果，响应客的请求
接收主程序指令，比如重启，升级和退出等
```



![](/images/posts/03_nginx/00/3.png)



### 2.2.2 进程间通信：

工资进程是有主进程生成的，主进程使用fork（）函数，在Nginx服务器启动过程中主进程根据配置文件决定启动工作进程的数量，然后建立一张全局的工作表存放当前未退出的所有工作进程，主进程生成工作进程会将生成的工作进程加入到工作进程表中，并建立一个单向的管道并将其传递给工作进程，改管道于普通的管道不同，他是由主进程表中的索引和必要的文件描述等信息

主进程于外界通信号机制进行通信，当接收到需要处理的信号时，它通过管道向相关的工作进程发送正确的指令，每个工作进程都有能力捕获管道中的可读事件，当管道中有可写事件的时候，工作进程就会从管道中读取并解析指令，然后采用相应的执行动作，这样就完成了主进程于工作进程的交互

```
工作进程之间的通信原理基本上和主进程于工作进程的通信时一样的，只要工作进程之间能够取得彼此信息，建立管道即可通信，但是由于工作进程之间时完成隔离得，因此一个进程想要知道另外一个进程得状态信息就只能通过主进程来设置了
```



![](/images/posts/03_nginx/00/4.png)

## 2.3 Nginx模块介绍

核心模块：是Nginx服务器正常运行必不可少得模块，提供错误日志记录、配置文件解析、事件驱动机制、进程管理等核心功能

标准HTTP模块：提供HTTP协议解析相关得功能，比如：端口配置、网页编码设置、HTTP响应头设置等等

可选HTTP模块：主要用于扩展标准得HTTP功能，让Nginx能处理一些特殊得服务，比如: Flash多媒体传输、解析GeoIP请求、网络传输压缩、安全协议SLL支持等

邮件服务模块：主要用于支持Nginx得邮件服务，包括POP3协议、IMAP协议和SMTP协议得支持

第三方模块：是为了扩展Nginx服务器应用，完成开发者自定义功能，比如：Json支持、Lua支持等

nginx高度模块话，但其模块早期不支持DSO机制；1.9.11版本支持动态装载和卸载

模块分类：

```
核心模块：core module
标准模块:
HTTP模块：ngx_http_*
  HTTP Core modules 默认功能
  HTTP Optional modules 需编译时指定
Mail 模块 ngx_mail_*
Stream 模块 ngx_stream_*
第三方模块
```



![](/images/posts/03_nginx/00/5.png)





#### 2.4：Nginx安装：

  Nginx得安装版本分为Mainline version(主要开发版本，其实就是还处于开发板)、Stable version(当前最新稳定版)和Legacy versions（旧得稳定版），Nginx安装可以使用yum或源码安装，但是推荐使用源码，一是yum得版本比较旧，二是编译安装可以更方便自定义相关路径，三十使用源码编译可以自定义相关功能，更方便业务得使用，源码安装需要提前准备标准得编译器，GCC得全称是(GNU Compiler collection),其有GUN开发，并以GPL既LGPL许可，是自由得类UNIX既苹果电脑Mac OS x操作系统得标准编译器，因为GCC原本只能处理C语言，所以原名为GUN C语言编译器，后来得到快速发展可以处理C++,Fortran,passcal,objective-C,java以及Ada等其他语言，此外还需要Automake工具，已完成自动创建Makefile得工作，Nginx得一些模块需要依赖第三方库，比如pcre（自持rewrite）,zlib(支持gzip模块)和openssl(支持sll模块)等

### 2.4.1 Nginx yum安装

需要提前配置好epel源

```
[root@ng-1 ~]# yum -y install epel-release
[root@ng-1 ~]# yum -y install nginx
[root@ng-1 ~]# rpm -ql nginx
/etc/logrotate.d/nginx
/etc/nginx/fastcgi.conf
/etc/nginx/fastcgi.conf.default
/etc/nginx/fastcgi_params
/etc/nginx/fastcgi_params.default
/etc/nginx/koi-utf
/etc/nginx/koi-win
/etc/nginx/mime.types
/etc/nginx/mime.types.default
/etc/nginx/nginx.conf
/etc/nginx/nginx.conf.default
/etc/nginx/scgi_params
/etc/nginx/scgi_params.default
/etc/nginx/uwsgi_params
/etc/nginx/uwsgi_params.default
/etc/nginx/win-utf
/usr/bin/nginx-upgrade
/usr/lib/systemd/system/nginx.service
/usr/lib64/nginx/modules
/usr/sbin/nginx
/usr/share/doc/nginx-1.20.1
/usr/share/doc/nginx-1.20.1/CHANGES
/usr/share/doc/nginx-1.20.1/README
/usr/share/doc/nginx-1.20.1/README.dynamic
/usr/share/doc/nginx-1.20.1/UPGRADE-NOTES-1.6-to-1.10
/usr/share/licenses/nginx-1.20.1
/usr/share/licenses/nginx-1.20.1/LICENSE
/usr/share/man/man3/nginx.3pm.gz
/usr/share/man/man8/nginx-upgrade.8.gz
/usr/share/man/man8/nginx.8.gz
/usr/share/nginx/html/404.html
/usr/share/nginx/html/50x.html
/usr/share/nginx/html/en-US
/usr/share/nginx/html/icons
/usr/share/nginx/html/icons/poweredby.png
/usr/share/nginx/html/img
/usr/share/nginx/html/index.html
/usr/share/nginx/html/nginx-logo.png
/usr/share/nginx/html/poweredby.png
/usr/share/nginx/modules
/usr/share/vim/vimfiles/ftdetect/nginx.vim
/usr/share/vim/vimfiles/ftplugin/nginx.vim
/usr/share/vim/vimfiles/indent/nginx.vim
/usr/share/vim/vimfiles/syntax/nginx.vim
/var/lib/nginx
/var/lib/nginx/tmp
/var/log/nginx
/var/log/nginx/access.log
/var/log/nginx/error.log

[root@ng-1 ~]# which nginx
/usr/sbin/nginx
```

#### 2.4.1.1： 检查安装：

查看nginx安装包信息

```
[root@ng-1 ~]# which nginx
/usr/sbin/nginx
[root@ng-1 ~]# rpm -qi nginx
Name        : nginx
Epoch       : 1
Version     : 1.20.1
Release     : 9.el7
Architecture: x86_64
Install Date: Tue 29 Mar 2022 05:26:03 PM CST
Group       : Unspecified
Size        : 1766800
License     : BSD
Signature   : RSA/SHA256, Tue 19 Oct 2021 08:41:45 AM CST, Key ID 6a2faea2352c64e5
Source RPM  : nginx-1.20.1-9.el7.src.rpm
Build Date  : Tue 19 Oct 2021 07:58:23 AM CST
Build Host  : buildhw-x86-12.iad2.fedoraproject.org
Relocations : (not relocatable)
Packager    : Fedora Project
Vendor      : Fedora Project
URL         : https://nginx.org
Bug URL     : https://bugz.fedoraproject.org/nginx
Summary     : A high performance web server and reverse proxy server
Description :
Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and
IMAP protocols, with a strong focus on high concurrency, performance and low
memory usage.

```

#### 2.4.1.2 查看帮助

使用安装完成得二进制文件nginx

```
[root@ng-1 ~]# nginx -h
nginx version: nginx/1.20.1
Usage: nginx [-?hvVtTq] [-s signal] [-p prefix]
             [-e filename] [-c filename] [-g directives]

Options:
  -?,-h         : this help
  -v            : show version and exit
  -V            : show version and configure options then exit
  -t            : test configuration and exit
  -T            : test configuration, dump it and exit
  -q            : suppress non-error messages during configuration testing
  模式
  -s signal     : send signal to a master process: stop, quit, reopen, reload
  发送信号
  -p prefix     : set prefix path (default: /usr/share/nginx/)
  -e filename   : set error log file (default: /var/log/nginx/error.log)
  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)  
  -g directives : set global directives out of configuration file
  文件路径

```

#### 2.4.1.3 验证Nginx

```
[root@ng-1 ~]# nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
[root@ng-1 ~]# nginx -V
nginx version: nginx/1.20.1
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
built with OpenSSL 1.1.1g FIPS  21 Apr 2020 (running with OpenSSL 1.1.1k  FIPS 25 Mar 2021)
TLS SNI support enabled
configure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-compat --with-debug --with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_mp4_module --with-http_perl_module=dynamic --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_xslt_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic' --with-ld-opt='-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E'

```

#### 2.4.1.4 Nginx启动脚本

```
[root@ng-1 ~]# cat /usr/lib/systemd/system/nginx.service
[Unit]
Description=The nginx HTTP and reverse proxy server
After=network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
# Nginx will fail to start if /run/nginx.pid already exists but has the wrong
# SELinux context. This might happen when running `nginx -t` from the cmdline.
# https://bugzilla.redhat.com/show_bug.cgi?id=1268621
ExecStartPre=/usr/bin/rm -f /run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t
ExecStart=/usr/sbin/nginx
ExecReload=/usr/sbin/nginx -s reload
KillSignal=SIGQUIT
TimeoutStopSec=5
KillMode=process
PrivateTmp=true

[Install]
WantedBy=multi-user.target

```

#### 2.4.1.5 配置Nginx

默认配置文件：/etc/nginx/nginx.conf,默认配置如下：

```
[root@ng-1 nginx]# grep -v "#" /etc/nginx/nginx.conf | grep -v "^$"
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;
include /usr/share/nginx/modules/*.conf;
events {
    worker_connections 1024;
}
http {
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;
    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 4096;
    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;
    include /etc/nginx/conf.d/*.conf;
    server {
        listen       80;
        listen       [::]:80;
        server_name  _;
        root         /usr/share/nginx/html;
        include /etc/nginx/default.d/*.conf;
        error_page 404 /404.html;
        location = /404.html {
        }
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
        }
    }
}

```

#### 2.4.1.6 启动Nginx

```
[root@ng-1 nginx]# systemctl start nginx
[root@ng-1 nginx]# systemctl status nginx
● nginx.service - The nginx HTTP and reverse proxy server
   Loaded: loaded (/usr/lib/systemd/system/nginx.service; disabled; vendor preset: disabled)
   Active: active (running) since Tue 2022-03-29 17:32:50 CST; 3s ago
  Process: 5131 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS)
  Process: 5129 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)
  Process: 5128 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)
 Main PID: 5133 (nginx)
   CGroup: /system.slice/nginx.service
           ├─5133 nginx: master process /usr/sbin/nginx
           └─5135 nginx: worker process

Mar 29 17:32:50 ng-1 systemd[1]: Starting The nginx HTTP and reverse proxy server...
Mar 29 17:32:50 ng-1 nginx[5129]: nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
Mar 29 17:32:50 ng-1 nginx[5129]: nginx: configuration file /etc/nginx/nginx.conf test is successful
Mar 29 17:32:50 ng-1 systemd[1]: Started The nginx HTTP and reverse proxy server.

[root@ng-1 nginx]# ps -ef | grep nginx
root       5133      1  0 17:32 ?        00:00:00 nginx: master process /usr/sbin/nginx
nginx      5135   5133  0 17:32 ?        00:00:00 nginx: worker process
root       5138   5025  0 17:33 pts/0    00:00:00 grep --color=auto nginx


```

#### 2.4.1.7 访问Nginx

![](/images/posts/03_nginx/00/6.png)

### 2.4.2 Nginx编译安装：

准备编译安装的基础环境：

```
[root@ng-1 ~]# yum -y install vim lrzsz tree lsof tcpdump wget ntpdate gcc gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel net-tools iotop zip unzip zlib-devel nfs-utils libxml2 libxml2-devel libxslt libxslt-devel perl perl-ExtUtils-Embed


```

#### 2.4.2.1 安装Nginx

官方源码包下载地址：

https://nginx.org/en/doenload.html

```
[root@ng-1 src]# ll
total 1016
-rw-r--r-- 1 root root 1039530 Nov 12 16:48 nginx-1.18.0.tar.gz
[root@ng-1 src]# tar -xf nginx-1.18.0.tar.gz
[root@ng-1 src]# cd nginx-1.18.0
编译是为了检查系统环境是否符合编译安装得要求，比如是否有gcc编译工具，是否支持编译参数当中得模块，并根据开启得参数等生成Makefile文件为下一步做准备

[root@ng-1 nginx-1.18.0]# ./configure --help #查看帮助
[root@ng-1 nginx-1.18.0]# ./configure --prefix=/usr/local/nginx \
--user=nginx --group=nginx \
--with-http_ssl_module \
--with-http_v2_module \
--with-http_realip_module \
--with-http_stub_status_module \
--with-http_gzip_static_module \
--with-pcre --with-stream \
--with-stream_ssl_module \
--with-stream_realip_module
[root@ng-1 nginx-1.18.0]# make #编译步骤，根据Makefile文件生成相应的模块
[root@ng-1 nginx-1.18.0]# make install #创建目录，并将生成的模块和文件复制到相应的目录
[root@ng-1 nginx-1.18.0]# useradd nginx -s /sbin/nologin -u 2000  #以普通用户启动nginx
[root@ng-1 ~]# chown nginx:nginx -R /apps/nginx/
[root@ng-1 ~]# /apps/nginx/sbin/nginx 
[root@ng-1 ~]# ps -ef | grep nginx
root       8602      1  0 21:58 ?        00:00:00 nginx: master process /apps/nginx/sbin/nginx
nginx      8603   8602  0 21:58 ?        00:00:00 nginx: worker process
```

备注：nginx完成安装以后，有四个主要的目录：

```
conf:改目录保存了nginx所有的配置文件，其中nginx.conf是nginx服务器的最核心最主要的配置文件，其他的.conf则是用来配置nginx相关的功能，例如fastcgi功能是使用的是fastcgi.conf和fastcgi_params两个文件，配置文件一般都有个样板配置文件，是文件名.default结尾，使用的使用将其复制为将default去掉即可
html：该目录中保存了nginx服务器的web文件，但是可以更改为其他目录保存web文件，另外还有一个50x的web文件是默认的错误页面提示页面
logs：该目录用来保存nginx服务器的访问日志错误日志等日志，logs目录可以放在其他路径，比如/var/logs/nginx里面
sbin：该目录用来保存nginx二进制启动脚本，可接受不同的参数以实现不同的功能。
```

#### 2.4.2.2 验证版本及编译参数

```
[root@ng-1 ~]# /apps/nginx/sbin/nginx -V
nginx version: nginx/1.18.0
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
built with OpenSSL 1.0.2k-fips  26 Jan 2017
TLS SNI support enabled
configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module

```

#### 2.4.2.3 访问编译安装的nginx web界面

![](/images/posts/03_nginx/00/7.png)

#### 2.4.2.4 创建Nginx自启动脚本

##### 2.4.2.4.1 Nginx 1.18.0

```
[root@ng-1 ~]# cat /usr/lib/systemd/system/nginx.service
[Unit]
Description=The nginx HTTP and reverse proxy server
After=network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
# Nginx will fail to start if /run/nginx.pid already exists but has the wrong
# SELinux context. This might happen when running `nginx -t` from the cmdline.
# https://bugzilla.redhat.com/show_bug.cgi?id=1268621
ExecStartPre=/usr/bin/rm -f /run/nginx.pid
ExecStartPre=/apps/nginx/sbin/nginx -t
ExecStart=/apps/nginx/sbin/nginx
ExecReload=/bin/kill -s HUP $MAINPID
KillSignal=SIGQUIT
TimeoutStopSec=5
KillMode=process
PrivateTmp=true

[Install]
WantedBy=multi-user.target

```



```
[root@ng-1 ~]# cat /lib/systemd/system/nginx.service
[Unit]
Description=The nginx HTTP and reverse proxy server
After=network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target

[Service]
Type=forking
PIDFile=/run/nginx.pid
# Nginx will fail to start if /run/nginx.pid already exists but has the wrong
# SELinux context. This might happen when running `nginx -t` from the cmdline.
# https://bugzilla.redhat.com/show_bug.cgi?id=1268621
ExecStartPre=/usr/bin/rm -f /run/nginx.pid
ExecStartPre=/apps/nginx/sbin/nginx -t
ExecStart=/apps/nginx/sbin/nginx
ExecReload=/bin/kill -s HUP $MAINPID
KillSignal=SIGQUIT
TimeoutStopSec=5
KillMode=process
PrivateTmp=true

[Install]
WantedBy=multi-user.target

```

#### 2.4.2.5 验证Nginx自启动脚本

```
[root@ng-1 ~]# systemctl daemon-reload
[root@ng-1 ~]# systemctl start nginx
[root@ng-1 ~]# systemctl enable nginx
Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.
[root@ng-1 ~]# systemctl status nginx
● nginx.service - The nginx HTTP and reverse proxy server
   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)
   Active: active (running) since Wed 2022-03-30 10:26:41 CST; 9s ago
   CGroup: /system.slice/nginx.service
           ├─5095 nginx: master process /apps/nginx/sbin/nginx
           └─5097 nginx: worker process

Mar 30 10:26:41 ng-1 systemd[1]: Starting The nginx HTTP and reverse proxy server...
Mar 30 10:26:41 ng-1 nginx[5090]: nginx: the configuration file /apps/nginx/conf/nginx.conf syntax is ok
Mar 30 10:26:41 ng-1 nginx[5090]: nginx: configuration file /apps/nginx/conf/nginx.conf test is s...sful
Mar 30 10:26:41 ng-1 systemd[1]: Can't open PID file /run/nginx.pid (yet?) after start: No such ...ctory
Mar 30 10:26:41 ng-1 systemd[1]: Started The nginx HTTP and reverse proxy server.

```

#### 2.5.2.6 配置Nginx

Nginx的配置文件的组成部分

主配置文件：nginx.conf 子配置文件 include conf.d/*.conf

```
fastcgi,uwsgi,scgi等协议相关的配置文件
mime.type:支持的mime类型。MIME多用途互联网邮件扩展类型。MIME消息能包含文本、图像、音频、视频以及其他应用程序专用的数据，是这顶某种扩展的文件用一种程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式

Nginx主配置文件的配置指令方式：
directive values [value2...];
注意：
（1）指令必须以分号结尾
（2）支持使用配置变量
  内建变量：由Nginx模块引入，可直接引用
  自定义变量：由用户用set命令定义
  		set variable_name value;
  引用变量：$variable_name
```

#### 2.5.2.7 默认配置文件

```
[root@ng-1 conf]# grep -v "#" /apps/nginx/conf/nginx.conf | grep -v "^$"
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
[root@ng-1 conf]# grep -v "#" /apps/nginx/conf/nginx.conf | grep -v "^$"
#全局配置端，对全局生效，主要设置nginx的启动用户/组，启动的工作进程数量，工作模式，Nginx的PID路径，日志路径等
user nginx nginx;
worker_processes  1; #启动工作进程的数量
worker_cpu_affinity auto;  cpu绑定
events { #events设置模块，主要影响nginx服务器于用户的网络连接，比如是否允许同时接受多个网络连接，使用那种事件驱动模式处理请求，每个工作进程可以同时支持的最大连接数，是否开启对多工作进程下的网络连接进行序列化等
    worker_connections  1024;  #设置单个nginx工作进程可以接受的最大并发，作为Web服务器的时候最大并发数为worker_connections * worker_processes，作为反向代理的时候为（worker_connections * worker_processes）/2,
}
http {#http块是Nginx服务器配置中的重要部分，缓存，代理和日志格式定义等绝大数功能和第三方模块可以在这设置，http块可以包含多个server块，而一个server块中又可以包含多个localtion块，server块可以配置文件引入，MIME-Type定义，日志自定义、是否启用sendfile、连接超时事件和单个链接的请求上限等

    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;#作为web服务器的时候打开sendfile加快静态文件传输，指定是否使用sendfile系统调用传输文件，sendfile通过DMA（直接内存访问）方式直接访问文件数据，并通过传输协议发送，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝，硬盘>>kernel buffer (快速拷贝到kernel socker buffer)>>协议栈。
   #DMA既 直接内存访问，DMA是一种不经过CPU而直接从内存读取数据的数据交换模式，可以将DMA认为是一种能够通过一组专用总线将内部和外部存储器与每个具有DMA能力的外设设备连接起来的控制器，在DMA模式下，CPU只须向DMA控制器下达指令，让DMA控制器处理数据的传送，数据传送完毕在把信息反馈给CPU，这样的很大程度减轻了CPU资源占有率，可以大大节省系统资源，一个处理器可以包含多个DMA控制器，每个控制器有多个DMA通道，以及多条直接与存储器站（memorybank）和外设连接的总线，在很多搞性能处理器中集成两种类型的DMA控制器，专门用于内部存储器所处位置之间的相互存取操作，既数据交换不需要经过CPU即可在不同的内存空间进程拷贝可以节省资源copy带来的上线文切换，可以直接在内存和I/O设备之间进行，可以大幅提高CPU性能
   
   
    keepalive_timeout  65; #长连接超时时间，单位是秒
    server { #设置一个虚拟机主机，可以包含自己的全局块，同时也可以包含多个location模块，比如本虚拟机监听的端口，本虚拟机的名称和IP配置，多个server可以使用一个端口，日不都使用80端口提供web服务器
        listen       80; #配置server监听端口
        server_name  localhost; #本sever的名称，当访问此名称的时候nginx会调用当前server内部的配置进行匹配
        location / { #location其实是server的一个指令，为nginx服务器提供比较多而且灵活的指令，都是在location中体现的，主要是基于nginx接收到的请求字符串，对用户请求的URL进行匹配，并对特定的指令进行处理，包括地址重定向，数据缓存和应答控制等功能都是在这部分实现，另外很多第三方模块的配置也是在location模块中配置
            root   html; #相当于默认页面的名称，默认是相对路径，可以使用决定队列配置
            index  index.html index.htm; #默认的页面文件名称
        }
        error_page   500 502 503 504  /50x.html; #错误页面的文件名称
        location = /50x.html { #location处理对应的不同错误码的页面定义到/50x.html，这个跟对应其server中定义的目录下
            root   html; #定义默认页面所在的目录
        }
    }
#和邮件相关的配置
#mail {
#		...
#}	mail协议相关配置段
#tcp代理配置 1.9版本以上支持
#stream {
#	...
#	}	stream 服务器相关配置段
#导入其他路径的配置文件
#include /apps/nginx/conf.d/*.conf
}

```

![](/images/posts/03_nginx/00/8.png)







# 三：Nginx核心配置详解

## 3.1 全局配置

```
user nginx nginx; #启动Nginx工作进程的用户和组
worker_processes [number|auto]; #启动Nginx工作进程的数量
worker_cpu_affinity 00000001 00000010 00000100 000010000; #将Nginx工作进程绑定到指定的cpu核心。默认Nginx是不进行进程绑定，绑定并不是意味着当前nginx进程独占一核心CPU，但是可以保存此进程不会运行在其他核心上，这就极大减少了nginx的工作进程在不同的cpu核心上的来回跳转，减少了CPU对进行的资源分配与回收以及内存管理等，因此可以有效的提升nginx服务器的性能

[root@ng-1 conf]# ps -axo pid,cmd,psr,user | grep nginx
  5095 nginx: master process /apps   0 root
  5188 nginx: worker process         0 nginx
  5189 nginx: worker process         0 nginx
  5191 grep --color=auto nginx       0 root
  
  #错误日志记录配置，语法：error_log file [debug | info | notice | warn | error | crit | alert | emerg]
 #error_log logs/error.log
 @error_log  logs/error.log notice;
 error_log /apps/nginx/logs/error.log error;
 #pid文件保存路径
 pid		/apps/nginx/logs/nginx.pid;
 
 worker_priority 0; #工作进程nice值，-20~19
 worker_rlimit_nofile 65536; #这个数字包括Nginx的所有连接（例如与代理服务器的连接等），而不仅仅是与客户端的连接，另一个考虑因素是实际的并发连接数不能超过系统级别的最大打开文件数的限制

[root@ng-1 conf]# watch -n1 'ps axo pid,cmd,nice | grep nginx' #验证进程优先级

daemon off; #前台运行Nginx服务用于测试、docker等环境
master_process off|on; #是否开启Nginx的master-work工作模式，仅用于开发调试场景

events {
	worker_connections 65546; #设置单个工作进程的最大并发连接数
	use epoll; #使用epoll事件驱动，Nginx支持众多的事件驱动，比如select、poll、epoll，只能设置在events模块中设置
  accept_mutex on;#优化同一时刻只有一个请求而避免多个睡眠进程被唤醒的设置，on为防止被同时唤醒，默认为off,全部唤醒的过程也成为“惊群”，因此nignx刚安装完以后要进行适当的优化
multi_accept on; #Nginx服务器的每个工作进程可以同时接受多个新的网络连接，但是需要在配置文件中配置，此指令默认为关闭，既默认为一个工作进程只能一次接受一个新的网络连接，打开后几个同时接受多个
}
```

## 3.2 http详细配置

```
http {
    include       mime.types;	#导入支持的文件类型
    default_type  application/octet-stream;  #设置默认的类型，会提示下载不匹配的类型文件

#日志配置部分
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;
#自定义优化参数
    sendfile        on;	#实现文件零拷贝
    #tcp_nopush     on; #在开启了sendfile的情况下，合并请求后统一发送给客户端
    #tcp_nodelay	off; #在开启了keepalived模式下的连接是否启用TCP_NODELAY选项，当为off时，延迟0.2s发送，默认on时，不延迟发送，立即发送用户相应报文

    #keepalive_timeout  0;
    keepalive_timeout  65; #设置会话保持时间

    #gzip  on;

    server {
        listen       80;
        server_name  loca;host; #设置server name ,可以以空格隔开多个并支持正则表达式，如*.aeotrade.com www.aeotrade.*
        

        #charset koi8-r; #设置编码格式，默认是俄语格式，可以改为utf-8

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504 /50x.html;
        location = /50x.html {  #定义错误页面
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ { #以http的方式转发php请求到指定web服务器
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ { #以fastcgi的方式转发php请求到php处理
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht { #拒绝web形式访问指定文件，如很多的网站都是通过.htaccess文件来改变自己的重定向等功能
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}

```

### 3.3.1 新建一个web站点

```
[root@ng-1 conf.d]# mkdir /apps/nginx/conf.d
[root@ng-1 conf.d]# cat pc.conf 
server {
	listen 80;
	server_name www.lcy.com;
	location / {
	root /data/nginx/html;
	}
}
[root@ng-1 conf.d]# mkdir /data/nginx/html -p
[root@ng-1 conf.d]# echo "app wen1" > /data/nginx/html/index.html
[root@ng-1 conf]# vim nginx.conf
include /apps/nginx/conf/conf.d/*.conf;
[root@ng-1 conf]# /apps/nginx/sbin/nginx -s reload
访问测试
```

### 3.3.2 root与alias

root 指定web的家目录，在定义location的时候，文件的绝对路径等于root+location，如

```
[root@ng-1 conf.d]# cat pc.conf 
server {
	listen 80;
	server_name www.lcy.com;
	location /portal {
	root /data/nginx;
	}
	location /about {
		root /data/nginx/html; #必须要在html目录中创建一个about目录材可以访问，否则报错。
	index index.html;
	}
}
[root@ng-1 conf.d]# mkdir /data/nginx/html/about
[root@ng-1 conf.d]# echo web app1 > /data/nginx/html/about/index.html
[root@ng-1 conf.d]# ../sbin/nginx -s reload

```

alias 定义路径别名，会把访问的路径中心定义到其指定的路径

```
server {
	listen 80;
	server_name www.lcy.com;
	location /portal {
	root /data/nginx;
	}
	location /about { #使用alias的时候url后面如果加了斜杠则下面的路径配置必须加斜杠，否正403
		alias /data/nginx/html; #当访问abot的时候，会显示alias定义的/data/nginx/html里面的内容
	index index.html;
	}
}

```

### 3.3.3 location的详细使用

在没有使用正则表达式的时候，nginx会现在server中的多个Location选取匹配度最高的一个uri,uri是用户请求的字符串，既域名后面的web文件路径，然后使用该location模块中的正则url和字符串，如果匹配成功就结束搜索，并使用此lication处理此请求

```
语法规则：location [=|~|~*|^~] /uri/ {...}

= #用于标准uri前，需要请求字符串与url精确匹配，如果匹配成功就停止向下匹配并立即处理请求
~ #用于标准url前，表示包含正则表达式并且区分大小写，并且匹配
！~ #用于标准Url前，表示包括正则表达式并且区分大小写，并且不匹配

~* #用于标准url前，表示包含正则表达式并且不区分大写，并且匹配
！~* #用于标准url前，表示包含正则表达式并且不区分大小写，并且不匹配

^~ #用于标准Url前，表示包含正则表达式并且匹配以什么开头
$ #用于标准url前，表示包含正则表达式并且匹配以什么结尾
\ #用于标准url前，表示包含正则表达式并且转义字符。可以转. * ？等
* #用于标准url前，表示包含正则表达式并且代表任意长读的任意字符
```

#### 3.3.4.1 匹配案例-精确匹配

在server部分使用location配置一个Web界面，要求：当访问Nginx服务器的时候/login的时候要显示指定的html文件内容

```
[root@ng-1 conf.d]# cat pc.conf 
server {
	listen 80;
	server_name www.lcy.com;
	location / {
	root /data/nginx/html;
	}
	location = /1.jpg {
		root /data/nginx/static;
	}
}

上传图片到/data/nginx/static，重启Nginx并访问测试
访问测试 http://www.lcy.com/1.jgp
```

#### 3.3.4.2 匹配案例-区分大小写

如果url中包含大写字母，则以下location匹配Ax.jpg条件不成功，因为~为区分大小写，那么当用户的请求被执行匹配时发现location中定义的是大写的A，则匹配失败，既要么继续往下匹配其他的location（如果有）要么报错给客户端

```
	location ~ /A.?\.jpg { #匹配字母A开头的图片，后面？表示A后面零次或一个字符
		index index.html;
		root /opt/nginx/html/image;
	}
重启Nginx并访问测试
```

#### 3.3.4.3 匹配案例-不区分大小写

对用户请求的url做模糊匹配，也就是uri中无论都是大写、都是小写或者大小写混合，此模式也都会匹配，通常使用此模式匹配用户request中的静态资源并绩效做下一步操作

```
        location ~* /A.*\.jpg {
                index index.html;
                root /opt/nginx/html/image;
        }
访问测试 http://www.lcy.com/ab.jpg 

对于不区分大小写的location,则可以访问任意大小写结尾的图片文件，如区分大小写则只能访问ab.jpg,不区分大小写则可以访问aa.jpg以为iade资源比如Ab.jpg.aA.jpg这样的混合名称文件，但是要求nginx服务器的资源目录有相应的文件，比如有Ab.jpg有aA.jpg
Nginx匹配一次文件名是否区分大小写
Nginx可以在服务器找到指定的资源
```

#### 3.3.4.4 匹配案例-URL开始

```
        location ^~ /images {
                root /data/nginx;
                index index.html;
}
访问测试 http://www.lcy.com/images
```

#### 3.3.4.5 匹配案例-文件名后缀

K	location ~* \.(gif|jpg|jpeg|bmp|png|tiff|tif|ico|wmf|js)$ {
		root /data/nginx/images;
		index index.html;

		location ~* \.(gif|jpg|jpeg|bmp|png|tiff|tif|ico|wmf|js)$ {
			root /data/nginx/images;
			index index.html;
	
		}
	重启Ngnixn并访问测试
	http://www.lcy.com/2.js

#### 3.3.4.6 匹配案例-优先级

```
匹配优先级： =，^~,~/~*,/
location优先级：（location=）>(location 完整路径)》（location ^~路径）>(location ~,~*正则顺序)>(location 部分起始路径)>(/)
```

### 3.3.5 Nginx三层访问控制

访问控制基于模块ngx_http_access_module实现，可以通过匹配客户端源IP地址进行限制

```
location /about {
	root /data/nginx/html;
	index index.html;
	allow 192.168.48.131; #运行找个IP访问
	deny all; #拒绝所有访问

}
```

### 3.3.6 自定义访问日志

```
server {
	listen 80;
	server_name www.lcy.com;
	error_log /var/log/www.lcy.com-error.log info;
	access_log /var/log/www.lcy.com-access.log main;
	location / {
	root /data/nginx/html;
	}
}
重启nginx并访问不存在得页面进行测试并验证是在指定目录生成新的日志文件
```

### 3.3.7 检测文件是否存在

try)files会顺序检查文件是否存在，返回第一个找到得文件或文件夹（结尾加斜线表示文件夹），如果所有文件或者文件夹都找不到，会进行一个内部重定向到最后一个参数，只有最后一个参数可以引起一个内部重定向，之前得参数只设置内部URL得指向，最后一个参数是回退UTL且必须存在，否正会出现内部500错误



```
        location /about {
        root /data/nginx/html;
        index index.html;
        try_files $uri /about/index.html;
        }
        
验证测试：www.lcy.com/about/2.txt  #会跳转到index.html页面上
```



### 3.3.8 长连接配置

keepalived_timeoout number; #设定保持连接超时时长，0表示禁止长连接，默认为75s，通常配置在http字段作为站点全局配置

keepalive_requests number; #在一次长连接上所允许的资源的最大数量，默认为100次

```
keepalive_requests 3;
keepalive_timeout 65 60;
开启长连接后，返回客户端的会话保持时间为60s，单次长连接累计请求到指定次数请求或65秒就会被断开，后面的60为发送给客户端应答报文头部显示的超时时间设置为60s；如不设置客户端将不显示超时时间

Keep-Alive:timeout=60 #浏览器收到的服务器返回的报文

如果设置为0表示关闭会话保持功能，将如下显示；
 Connection:close #浏览器收到的服务器返回的报文
 
 
 Trying 192.168.48.143...
Connected to www.lcy.com.
Escape character is '^]'.
GET / HTTP/1.1
HOST: www.lcy.com

HTTP/1.1 200 OK
Server: nginx/1.18.0
Date: Thu, 31 Mar 2022 14:32:08 GMT
Content-Type: text/html
Content-Length: 23
Last-Modified: Wed, 30 Mar 2022 09:06:26 GMT
Connection: close
ETag: "62441d92-17"
Accept-Ranges: bytes

<h1> hello world </h1>
Connection closed by foreign host.

```

### 3.3.9 作为下载服务器配置

```
[root@ng-1 ~]# mkdir /data/nginx/html/download
	location /download {
	autoindex on; #自动索引功能
	autoindex_exact_size on; #计算文件确切大小（单位bytes），off只显示大概大小（单位kb.mb.gb）
	autoindex_localtime on; #显示本机时间而费GMT时间
	root /data/nginx/html;
	}


```

![](/images/posts/03_nginx/00/9.png)

```
limit_rate tate; 限制相应客户端的传输速率，单位是bytes/second，默认值0表示无限制限速与不限速的对比；
limit_rate 5k;
```

![](/images/posts/03_nginx/00/10.png)



![](/images/posts/03_nginx/00/11.png)



### 3.3.10 作为上传服务器

```
client_max_body_size 1m;	#设置允许客户端上传单个文件的最大值，默认值为1m
clinet_body_buffer_size size; #用于接收每个客户端请求报文的body部分的缓冲区大小；默认16k，超出此大小时，其将被暂存到磁盘上的由下面client_body_temp_path指令所定义的位置
client_body_temp_path path [level1 [level2 [level3]]];
#设定存储客户端请求报文的Body部分的临时存储路径及子目录结构数量，目录名为16进制的数字，使用hash之后的值从后往前截取1位、2位、2位作为文件名
```

### 3.3.11 其他配置

```
keepalive_disable node | browser ....;

limit_except method ...{...}仅用于location
显示客户端使用了除了指定的请求方法之外的其他方法
method: GET,HEAD,POST,PUT,DELETE,MKCOL,COPY,MOVE,OPTIONS,PROPFIND,PROPPATCH,LOCK,UNLOCK,PATH
 limit_except GET {
 	allow 192.168.0.0/24
 	allow 192.168.48.143;
 	deny all;
 }
 #除了GET和HEAD之外其它方法仅允许192.168.48.0/24网段主机使用
 
 
 [root@k8s-node ~]# curl -XPUT http://www.lcy.com/about
<html>
<head><title>405 Not Allowed</title></head> #Nginx已经允许但是程序未支持上传功能
<body>
<center><h1>405 Not Allowed</h1></center>
<hr><center>nginx/1.18.0</center>
</body>
</html>


[root@k8s-node ~]# curl -XPUT http://www.lcy.com/upload
<html>
<head><title>403 Forbidden</title></head> #Nginx拒绝上传
<body>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.18.0</center>
</body>
</html>

aio on | off #是否启用asynchronous file I/O(AIO）功能，需要编译开启linux 2.6 以上内核提供以下几个系统调用来支持aio；
1.SYS_io_setup: 建立aio的context
2.SYS_io_submit: 提交I/O操作请求
3.SYS_io_getevents: 获取已完成的I/O事件
4.SYS_io_cancel: 取消I/O操作请求
5.SYS_io_destroy: 销毁aio的context

directio size | off; #directio是之间磁盘IP，默认为关闭，directio的设计初衷，它具备sendile的基本原理，知识不使用内核cache，而是直接使用DMA，当某个文件大于等于给定大小时会生效，小于此值会使用senfie，例如directio 4m,之间I/O最大的优点就是减少操作系统缓冲区和用户地址空间的拷贝次数，降低了CPU的开销和内存带宽，主要使用在磁盘上有较大文件的场合，比如视频、音频等

DMA数据传输过程：
1.DMA请求
	CPU对DMA控制器初始化，并向I/O接口发出操作命令，I/O接口提出DMA请求
2.DMA响应：
	DMA控制器通知I/O接口开始DMA传输
3.DMA传输
	DMA控制器获得总线控制权后，CPU不再进行数据拷贝，由DMA控制器输出读写命令，之间控制内存与I/O接口进行数据传输
4.DMA结束
	完成数据传输后，DMA控制器既释放总线控制权，并向I/O接口发出结束信号并通知CPU，CPU继续处理请求
	
总结：
	DMA传输不需要CPU之间参数于数据传输过程，也没有将CPU阻塞在数据拷贝的过程中，而实通过硬件内存于I/O设备建立一条直接传送数据的通路，在数据传输过程中CPU基础处理请求，使CPU的工作效率大为提高。
	
direction_alignment 512; #设置direction的对其方式，在大多数情况下，一个512字节的对其就足够了，但是，在Linux下使用XFS使，需要将其增加到4k

#directio可以和sebdfile结合使用不冲突，在Linux上同时启用AIO和sendfile时，AIO用于大于或等于directio指令中指定的大小的文件，而sendfile用于较小的文件或禁用directio的内文件，directio需要nginx开启aio如：
	location /video {
		root /data/video;
		index index.html;
		sendfile on;
		aio onl;
		directio 8m;
		directio_alignment 512;
	
	}
	
http://nginx.org/en/docs/ngx_core_module.html #thread_poll #开启多线程，定义多线程读取和发送文件而不会阻塞

http://nginx.org/en/docs/ngx_core_module.html #aio 

open_file_cache max=10000 inactive=60s; #最大缓存10000个文件，非活动数据超时时长60s
open_file_cache_valid 60s; 每间隔60s检查一下缓存数据有效性
open_file_cache_min_users 5; #60秒内至少命中访问5次被标记为活动数据
open_file_cache_errors on;缓存错误信息


server_tokens off; #隐藏Nginx server版本

```

# 四：Nginx高级配置

## 4.1 Nginx状态页

基于nginx模块ngx_http_stub_status_module实现，在编译安装nginx的时候需要添加编译参数--with-http_stub_status_module，否则配置完成之后检测会时提示语法错误

```
配置示例：
	location /nginx_status {
		stub_status;
		allow 192.168.48.0/24;
		deny all;
	
	}
状态页用于输出nginx的基本状态信息
	输出信息示例
Active connections: 291
server accepts handled requests
166  1444  310
上面三个数字分别对应accepts handled requests三个值
Reading:6 Writing: 179 Waiting: 106

Active connections: 当前处于活动状态的客户端连接数，包括连接等待空闲连接数
accepts: 统计总值，Nginx自启动后已结束的客户端请求的总数
handled: 统计总值，Nginx自启动后已处理完成的客户端请求的总数，通常等于accepts,除非有因worker_connections限制等被拒绝的连接
requests:统计总值，Nginx自启动后客户端发来的总的请求数
Reading: 当前状态，正在读取客户端请求报文首部的连接的连接数
Writing:当前状态，正在向客户端发送响应报文过程中的连接数
Waiting:当前状态，正在等待客户端发出请求的空闲连接数，开启keep-alived的情况下，这个值等于active - (reading+writing)
```

## 4.2 Nginx第三方模块

第三方模式是对nginx的功能扩展，第三方模块需要在编译安装Nginx的时候使用参数--add-module-PATH指定路径添加，有的模块是由公司的开发人员针对业务需求定制开发的，有的模块是开源爱好者开发好之后上传到github进行开源的模块，nginx支持第三方模块需要从源码重新编译支持，比如开源的echo 模块https://github.com/openresty/echo-nginx-module;

```
[root@ng-1 ~]# yum -y install git
[root@ng-1 src]# git clone https://github.com/openresty/echo-nginx-module.git

[root@ng-1 nginx-1.18.0]# ./configure --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module --with-threads --add-module=/usr/local/src/echo-nginx-module

[root@ng-1 nginx-1.18.0]# make && make install
[root@ng-1 nginx-1.18.0]# /apps/nginx/sbin/nginx -s reload
[root@ng-1 conf.d]# cat pc.conf 
server {
	listen 80;
	server_name www.lcy.com;
	location / {
	root /data/nginx/html;
	}
	location /main {
	index index.html;
	default_type text/html;
	echo "heelo world";
	echo_reset_timer;
	echo_location /sub1;
	echo_location /sub2;
}
	location /sub1 {
	default_type text/html;
	echo_sleep 1;
	echo sub1;	
	}
	location /sub2 {
	echo_sleep 1;
	echo sub2;
	}
}

验证访问
http://www.lcy.com/main

```

## 4.3 Nginx变量使用

nginx的变量可以在配置文件中引用、作为功能判断或者日志等场景使用，变量可以分为内置变量和自定义变量，内置变量是由nginx模块自带，通过变量可以获取到众多的与客户端访问相关的值。

### 4.3.1 内置变量

```
$remote_addr;
#存放了客户端的地址，是客户端的公网IP，也就是一家人访问一个网站，则会显示为路由器的公网IP
```

```
$args:
#变量中存放了URL中的指令
```

```
$document_root;
#保存了当前针对当前资源的请求的系统根目录，如/apps/nginx/html
```

```
$document_uri;
#保存了当前请求中不包含指令的URL
```

```
$host
#存放了请求的host名称
```

```
$http_user_agent
#客户端浏览器的详细信息
```

```
$http_cookie
#客户端的cookie信息
```

```
limit_rate 10240
echo $limit_rate
#如果nginx服务器使用limit_rate配置了显示网络速率，则会显示，如果没有设置，则显示0
```

```
$remote_port
#客户端请求Nginx服务器随机打开的端口，这是每个客户端自己的端口
```

```
$remote_user
#已经经过Auth Basic Module验证的用户名
```

```
$request_body_file
#做反向代理时发给后端服务器的本地资源的名称
```

```
$request_method
#请求资源的方式，GET/PUT/DELETE等
```

```
$request_filename
#当前请求的资源文件的路径名称，由root或alias指令于URL请求生成的文件绝对路径
如/apps/nginx/html/main/index.html
```

```
$request_uri
#包含请求参数的原始URI，不包含主机名，如/amin/index.do>id=2022.....
```

```
$scheme
#请求的协议，如ftp,https,http等
```

```
$server_protocol
#保存了客户端请求资源使用的协议的版本，如HTTP/1.0,HTTP/1.1 HTTP/2.O等
```

```
$server_addr;
#保存了服务器的IP地址
```

```
$server_name
#请求服务器的主机名
```

```
$server_port;
#请求的服务器的端口号
```

### 4.3.2 自定义变量

假如需要自定义变量名和值，使用指令set $variable value; 则方法如下

```
set $name lcy;
echo $name;
set $my_port $server_port;
echo $my_port;
```

## 4.4 Nginx压缩功能

Nginx支持对指定类型的文件进行压缩然后在传输给客户端，而且压缩还可以设置压缩比例，压缩后的文件大小将比源文件显著变小，这样有助于降低出口带宽的利用率，降低企业的IT支出，不过会占用相应CPU资源

Nginx对文件的压缩功能时依赖于模块ngx_http_gzip_module

官方文档：https://nginx.org/en/docs/http/ngx_http_gzip_module.html

```
#启用或者禁用gzip压缩，默认关闭
gzip on | off;

#压缩比由低到高从1到9，默认为1
gzip_comp_level level;

#禁用IE6 gzip功能
gzip_disable "MSIE [1-6]\.";

#gzip压缩的最小文件，小于设置值的文件将不会压缩
gzip_min_length 1k;

#启用压缩功能，协议的最小版本，默认HTTP/1.1
gzip_http_version 1.0 | 1.1;

#指定Nginx服务需要向服务器申请的缓存空间的个数*大小，默认32 4k|16 8k;
gzip_buffers number size;

#指明仅对哪些类型的资源执行压缩功能操作，默认为gzip_types text/html 不用显示指定，否则出错
gzip_types mime-type ...;

#如果启用压缩，释放在相应报文首部插入“Vary: Accept-Encoding”
gzip_vary on | off;

[root@ng-1 conf]# vim nginx.conf
    gzip  on;
    gzip_comp_level 5;
    gzip_min_length 1K;
    gzip_types text/plain application/javascript application/x-javascript text/cssapplication/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
	gzip_vary on;


重启Nginx并访问测试

[root@ng-1 conf]# curl --head --compressed http://www.lcy.com
HTTP/1.1 200 OK
Server: nginx
Date: Sun, 03 Apr 2022 11:00:30 GMT
Content-Type: text/html
Content-Length: 23
Last-Modified: Wed, 30 Mar 2022 09:06:26 GMT
Connection: keep-alive
ETag: "62441d92-17"
Accept-Ranges: bytes

[root@ng-1 conf]# curl --head --compressed http://www.lcy.com/m5.html
HTTP/1.1 200 OK
Server: nginx
Date: Sun, 03 Apr 2022 11:00:58 GMT
Content-Type: text/html
Last-Modified: Sun, 03 Apr 2022 10:54:04 GMT
Connection: keep-alive
Vary: Accept-Encoding
ETag: W/"62497ccc-23688c"
Content-Encoding: gzip #压缩传输


```

## 4.5 http功能

web网站的登录页面都是使用https加密传输的，加密数据以保障数据的安全，HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等安全级别较高的服务都会采用HTTPS协议，HTTPS其实是有两个部分组成，HTTP+SSL/TLS 也就是在HTTP上又加了一层处理加密信息的模块，服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据

![](/images/posts/03_nginx/00/12.png)



```
https 实现过程如下
1.客户端发起HTTPS请求；
客户端访问某个web端的https地址，一般都是443端口

2.服务器的配置
采用https协议的服务器必须要有一套证书，可以通过一些组织申请，也可以之际制作，目前国内很多网站都是自己做的，当你访问一个网站的时候提示不可信任就表示证书是自己做的，证书就是一个公钥和私钥，就像一把锁和要是，正常情况下只有你的要是可以打开你的锁，你可以把这个送给别人让他锁住一个箱子，里面放满了钱或密码，别人不知道里面放了什么而且别人也打不开，只有你的钥匙是可以打开的

3.传送证书
服务端给客户端传递证书，启时就是公钥，里面包含了很多信息，例如证书的到颁发机构，过期时间等等。

4.客户端解析证书
这部分工资是有客户端完成的首先会验证公钥的有效性，比如办法机构，过期时间等等，如果发现异常则会弹出一个警告提示证书可能存在问题，如果证书没有问题，就生成一个随机值，然后用证书对该随机值进行加密，就像2步骤所说把随机值锁起来，不让别人看到

5.传送4步骤的加密数据
就是将证书加密后的随机值传递给服务器，目的就是为了让服务器得到这个随机值，以后客户端和服务器的通信就是可以通过这个随机值进行加密解密了

6.服务端解密信息
服务端用私钥解密5步骤加密后的随机值后，得到了客户端传递过来的随机值，然后把内容通过该值进行对称加密，对称加密就是将信息和私钥通过算法混合在一起，这样除非你知道私钥，不然是无法获取其内容的，而正好客户端和服务端都知道这个私钥，所以只要机密算法够发杂就可以保证数据的安全性。

7.传输加密后的信息
服务端将私钥加密后的数据传递给哭护短，在客户端可以被还原出数据内容

8.客户端解密信息
客户端之前生成的私钥获取界面服务器端传递过来的数据，由于数据一直都是加密的，因此即使第三方获取到数据也无法知道其详细内容
```

### 4.5.1 ssl配置参数

nginx的https功能基于模块ngx_http_ssl_module实现，因此如果是编译安装的nignx要使用参数ngx_http_ssl_module开启sll功能，但是作为nginx的核心功能，yum安装的Nginx模式就是开启的，编译安装的nginx需要指定编译参数--with-http_ssl_module开启

官方文档：https://nginx.org/en/docs/http/ngx_http_ssl_module.html



```
#为指定的虚拟主机配置是否开启sll功能，此功能在1.15.0废弃，使用listen{ssl}替代
ssl on | off;

#当虚拟主机使用的公钥文件，一般是crt文件
ssl_certificate /path/to/file;
#当前虚拟主机使用的私钥文件，一般是key文件
ssl_certificate_key /path/to/file;

#支持sll协议版本，早期为sll，现在是TLS，默认为后三个
ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2]

#配置ssl缓存
ssl_session_cache off | none | [builtin[:size][shared:name:size]];
off 关闭缓存
node： 通知客户端支持ssl session cache, 但实际不支持
builtin[:size] 使用openssl内建缓存，为每个worker进程私有
[shared:name:size]在各worker之间使用一个共享缓存，需要定义一个缓存名称和缓存空间大小，一兆可以存储4000各会话信息，多个虚拟主机可以使用相同的缓存名称

#客户端连接可以复用sll session cache中缓存的有效时长。默认5m
sll_session_timeout time；
```

### 2.5.2 自签名证书

```
[root@ng-1 nginx]# mkdir certs
[root@ng-1 nginx]# cd certs/
[root@ng-1 certs]# openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 3650 -out ca.crt   #自签CA证书
Generating a 4096 bit RSA private key
................................................................................................++
.....................................................++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN #国家代码
State or Province Name (full name) []:BeiJing #省份
Locality Name (eg, city) [Default City]:BeiJing #城市名称
Organization Name (eg, company) [Default Company Ltd]: #公司名称
Organizational Unit Name (eg, section) []: #部门
Common Name (eg, your name or your server's hostname) []:
Email Address []:
[root@ng-1 certs]# ll
total 8
-rw-r--r-- 1 root root 1960 Apr  3 20:38 ca.crt
-rw-r--r-- 1 root root 3272 Apr  3 20:38 ca.key


#资质key和csr文件
[root@ng-1 certs]# openssl req -newkey rsa:4096 -nodes -sha256 -keyout www.lcy.com.key -out www.lcy.com.csr
Generating a 4096 bit RSA private key
...++
.................................++
writing new private key to 'www.lcy.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:BeiJing
Locality Name (eg, city) [Default City]:BeiJing
Organization Name (eg, company) [Default Company Ltd]:lcy.com
Organizational Unit Name (eg, section) []:lcy.com
Common Name (eg, your name or your server's hostname) []:www.lcy.com
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:

#签发证书
[root@ng-1 certs]# [root@ng-1 certs]# openssl x509 -req -days 3650 -in www.lcy.com.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out www.lcy.com.crt
Signature ok
subject=/C=CN/ST=BeiJing/L=BeiJing/O=lcy.com/OU=lcy.com/CN=www.lcy.com
Getting CA Private Key

#验证证书内容
[root@ng-1 certs]# openssl x509 -in www.lcy.com.crt -noout -text
```

### 4.5.3 Nginx证书配置

```
listen 80;
listen 443 ssl;
ssl_certificate /apps/nginx/certs/www.lcy.com.crt
ssl_certificate_key /apps/nginx/certs/www.lcy.com.key
ssl_session_cache shared:sslcache:20m;
ssl_session_timeout 10m;
```

## 4.7 关于favicon.ico

favicon.ico文件时浏览器收藏网址时显示的图片，当客户端使用浏览器页面时，浏览器会自动发起请求获取页面的favicon.ico文件，但是当浏览器请求的ifcivon.ico文件不存在时，服务器会记录404日志，而且浏览器也会显示404报错

解决方法：

```
#将图片保存到指定目录访问
location = /favicon.ico {
	root /data/nginx/html/images;
	expires 90d; #设置文件过期时间

}
```

## 4.8 安全选项

### 4.8.1 隐藏Nginx版本号

更改nginx源码信息并重新编译Nginx

```
[root@ng-1 nginx]# sbin/nginx -s stop
[root@ng-1 nginx-1.18.0]# vim src/http/ngx_http_header_filter_module.c 
 49 static u_char ngx_http_server_string[] = "Server: lcy" CRLF;
 
 
[root@ng-1 nginx-1.18.0]# /apps/nginx/sbin/nginx -V

configure arguments: --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module --with-threads --add-module=/usr/local/src/echo-nginx-module



[root@ng-1 nginx-1.18.0]# ./configure --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module --with-threads --add-module=/usr/local/src/echo-nginx-module
#重启gnginx
[root@ng-1 nginx-1.18.0]# /apps/nginx/sbin/nginx
 
```

![](/images/posts/03_nginx/00/13.png)





### 4.8.2 升级OpenSSl版本

心脏出血，也简称为心血漏洞，是一个出现在加密程序库OpenSSL的安全漏洞，该程序库广发用于实现互联网的传输层安全（TLS）协议，它与2012年被引入了软件中，2014年4月首次公众披露，只要使用的时存在OpesnSLL实例，无论时服务器还是客户端，都可能因此而受到攻击，此问题的原因是在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查），因此漏洞的名称来源于“心跳”，该程序错误属于缓冲区过读，即可读取的数据比应该允许读物的还多

```
#准备OpenSSly源码包

[root@ng-1 nginx-1.18.0]# ./configure --prefix=/apps/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module --with-pcre --with-stream --with-stream_ssl_module --with-stream_realip_module --with-threads --add-module=/usr/local/src/echo-nginx-module --with-openssl=/usr/local/src/openssl-1.1.1l

[root@ng-1 nginx-1.18.0]# make && make install
[root@ng-1 nginx-1.18.0]# /apps/nginx/sbin/nginx -s reload
[root@ng-1 nginx-1.18.0]# /apps/nginx/sbin/nginx -V
nginx version: nginx/1.18.0
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
built with OpenSSL 1.1.1l  24 Aug 2021

```





# 五：Nginx Rewrite 相关功能

Nginx服务器利用ngx_http_rewrite_module模块解析和处理rewrite请求，此功能依靠PCRE，因此编译之前要安装PCRE库，rewrite时nginx服务器的重要功能之一，用于实现URL的重写，URL的重写时非常有用的功能，比如它可以在我们改变网站结构之后，不需要客户端修改原来的书签，也无需其他网站修改我们的链接，就可以设置为访问，另外还可以在一定程度上提高网站的安全性

http://www.pcre.org #PCRE官方站点

## 5.1 ngx_http_rewrite_module模块指令

https://nginx.org/en/docs/http/ngx_http_rewrite_module.html

### 5.1.1 if指令

用于条件匹配判断，并根据条件判断结果选择不通的Nginx配置，可以配置在server或location行配置，Nginx的if语法仅能使用if做单词判断，不支持使用if else或者if elif这样的多重判断

```
if (条件匹配){
	action

}
```

使用正则表达式对变量进行匹配，匹配成功时if指令认为条件为true，否正认为false，变量于表达式之间使用以下符号链接

```
=：#比较变量和字符串是否相等，相等时if指令认为条件为true，反之为false
！=：#比较变量和字符串
~：#表示在匹配过程中区分大小写字符，（可以通过正则表达式匹配），满足匹配条件为真，不满足为假
！~：#区分大小写字符串匹配结果不匹配，不满足为真，满足为假

~*：#表示在匹配过程中不区分大小写字符，（可以通过正则表达式匹配），满足匹配条件为真，不满足为假
！~*：#为不区分大小字符匹配结果不匹配，满足为假，不满足为真


-f 和！-f：#判断请求的文件是否存在和是否不存在
-d 和！-d:#判断请求的目录是否存在和是否不存在
-x和！ -x:#判断文件是否可执行和是否不可执行
-e和！-e: #判断请求的文件或目录是否存在和是否不存在（包括文件、目录、软连接）


```

### 5.1.2 set指令

指定key并给其定义一个变量，变量可以调用Nginx内置变量赋值给key，另外set定义格式为set $key $value，及无论时key还是value都要加$符号

```
location /main {

	root /data/nginx/html;
	index index.html;
	default_type text/html;
		set $name lcy;
		echo $name
		set $my_port $server_port;
		echo $my_port;
}
```

### 5.1.3 bread指令

用于中断当前相同作用域(location)中的其他Nginx配置，与该指令处于同一作用域的Nginx配置中，位于它前面的配置生效，位于后面的指令配置就不在生效了，Nginx服务器在根据配置处理请求的过程中遇到该指令的时候，回到上一层作用域继续向下读取配置，该指令可以在server块和location块以及if块中使用

```
       location / {
        root /data/nginx/html;
        set $name lcy;
        echo $name;
        break;
        set $my_port $server_port;
        echo $my_port;
        }

	
```

### 5.1.4 return指令

从nginx版本0.8.42开始支持，return用于完成对请求的处理，并直接向客户端返回相应状态码，比如其可以指定重定向URL（对于特殊重定向状态码，301/302等）或者是指定提示文件内容（对于特殊状态码403/500等），处于次指令后的所有配置都将不被执行，return可以在server、if和location块进行配置

```
        server_name www.lcy.com;
        default_type text/html;
        location / {
        root /data/nginx/html;
        return 301 http://www.aeotrade.com;
        }

```

## 5.2 rewrite指令

通过正则表达式的匹配来改变URI，可以同时存在一个或多个指令，按照顺序一次对URI进行匹配，rewrite主要是针对用户请求的URL或者是URI做集体处理

```
URI：通用资源标识符，标识一个资源的路径，可以不带协议
URL：统一资源定义符，是用于在Internet中描述资源的字符串，是URI的子集，主要包括传输协议、主机和资源具体地址等三部分，一般格式位scheme：//主机名[:端口号][/资源路径]，如：http://www.a.com:8080/path/file/index.html就是一个URL路径，URL必须带访问协议。
每个URL都是一个URI，但是URI不都是URL。

例如：
http://example.org:8080/path/to/resource.txt #URI/URL
ftp://example.org/resource.txt #URI/URL
/absolt/path/to/resource.txt #URI
```

reewrite的官方介绍地址：https://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite

rewrite可以配置在server、location、if

```
rewrite regex replacement [flag];
rewrite 正则匹配客户端请求 修改后的请求 标记位

```

rewrite将用户请求的URI基于regex所描述的模式进行检查，匹配到时将其替换位表达式指定的新的URI

如果在同一级配置块中存在多个rewrite规则，那么会自行而下琢个检查，被某条件规则替换完成后，会重新一轮的替换检查，隐含有循环机制，但不超过10次，如果超过，提示500响应码，[flag]所表示的标志位用于控制此循环机制，如果替换后的URL是以http://或https://开头，则替换结果会直接以重向返回给客户端，既永久重定向301



### 5.2.1 rewrite flag使用介绍

利用nginx的rewrite的指令，可以实现url的重新跳转，rewrite有四种不同的flaf,分别是redirect(临时重定向，状态码302)、permanent（永久重定向，状态码301）、break和last。其中前两种是跳转型的flag，后两种是代理型，跳转型是指有客户端浏览器重新对新地址进行请求，代理型是在WEB服务器内部实现跳转的



```
redirect
#临时重定向，重写完成以后临时重定向方式直接返回重写后生成写的URL给客户端，由客户端重新发起请求，使用相对路径，或者http://或https://开头，状态码：302

permanent
#重写完成后以永久重定向方式直接返回重写生成的新URL给客户端，由客户端重新发起请求，状态码：301

last:
#重写完成后停止对当前URI在当前location中后续的其他重写操作，而后对新的URL启动新一轮重写检查、不建议在location配置环境中使用

break
#重写完成后停止对当前URL在当前location中后续的其他重写操作，而后直接将匹配结果返回给客户端既结束循环并返回数据给客户端，建议在多location配置环境中使用
```

### 5.2.2 rewrite案例-域名永久与临时重定向：

将访问源域名www.lcy.com的请求永久重定向要www.aeotrade.com

临时重定向不会缓存域名解决记录，但是永久重定向会缓存

```
	server_name www.lcy.com;
	default_type text/html;
	location / {
	root /data/nginx/html;
	rewrite / http://www.aeotrade.com permanent;
	#rewrite / http://www.aeotrade.com redirect;
	}
}

```

#### 5.2.2.1 永久重定向

域名永久重定向（permanent redirect）状态码为301,浏览器会缓存DNS解析记录

![](/images/posts/03_nginx/00/14.png)

#### 5.2.2.2 临时重定向

域名临时重定向（temporarily moved）状态码为302，告诉浏览器域名不是固定重定向到当前目标域名，后期可能随时会更改，因此浏览器不会缓存当前域名的解析记录，而浏览器会缓存永久重定向的DNS解析记录，这也是临时重定向与永久重定向最大的本质区别

![](/images/posts/03_nginx/00/15.png)



### 5.2.3 rewrite案例-break与last

#### 5.2.3.1 break案例

```
bread测试案例:当客户端访问Break的时候，测试通过rewrite将URL重写为test1，然后在通过rewrite将test1重写为test2测试两条write规则最终哪条生效

	location /break {
		root /data/nginx;
		index index.html;
		rewrite ^/break/(.*) /test1/$1 break; #break匹配成功后不在向下匹配，也不会跳转到其他Location,既结束匹配并给客户端返回结果数据
		rewrite ^/test1/(.*) /test2/$1 break; #break不会匹配后面的rewrite规则也不匹配其他location
	}
	
	location = /test1 {
		index index.html;
		root /data/nginx;
	}
	location = /test2 {
		index index.html;
		root /data/nginx;
	}


#创建资源路径
[root@ng-1 conf.d]# mkdir /data/nginx/test1
[root@ng-1 conf.d]# mkdir /data/nginx/test2
[root@ng-1 conf.d]# mkdir /data/nginx/break
[root@ng-1 conf.d]# echo "bread" > /data/nginx/break/index.html
[root@ng-1 conf.d]# echo "test1" > /data/nginx/test1/index.html
[root@ng-1 conf.d]# echo "test2" > /data/nginx/test2/index.html

break访问测试
[root@ng-1 conf.d]# curl -L http://www.lcy.com/break
test1

```

#### 5.2.3.2 last案例

```
last: 对某个location的URL匹配成功后会停止当前location的后续rewrite规则，并结束当前Location，然后将匹配生成的新URL跳转到至其他location继续匹配，知道没有location可匹配后将最后一次location的数据返回给客户端

	location /last {
		root /data/nginx;
		index index.html;
		rewrite ^/last/(.*) /test1/$1 last;
	}
	location = /test1/index.html {
		index index.html;
		root /data/nginx;
	}
	location = /test2/index.html {
		index index.html;
		root /data/nginx;
	}
	
last访问测试
[root@ng-1 conf.d]# curl -L http://www.lcy.com/last/
test1


```

### 5.2.4 rewrite案例-自动跳转https

基于通信安全考虑公司网站要求全站Https，因此要求将在不影响用户请求的情况下将Http请求全部跳转至https，另外也可以实现部分location跳转

```
server {
	listen 80;
	listen 443 ssl;
	ssl_certificate /apps/nginx/certs/www.lcy.com.crt;
	ssl_certificate_key /apps/nginx/certs/www.lcy.com.key;
	ssl_session_cache shared:sslcache:20m;
	ssl_session_timeout 10m;

	server_name www.lcy.com;
	default_type text/html;
	location / {
	index index.html;
	root /data/nginx;
	if ($scheme = http){
	 rewrite / https://www.lcy.com permanent;
		}	
	}
	
}

重启nginx并访问测试
http://www.lcy.com
```

### 5.2.4 rewrite案例-判断文件是否存在

当用户访问到公司网站的时输入一个错误的URL，可以将用户重定向至官网首页

```
	location / {
	index index.html;
	root /data/nginx;
	if (!-f $request_filename){
	 rewrite (.*) https://www.lcy.com/index.html;
		}	
	}

```



# 六：Nginx反向代理功能

反向代理：方向代理也叫reverse proxy，指的时代理外网用户的请求到内网的指定web服务器，并将数据返回给用户的一种方式，这是用的比较多的一种方式

Nginx除了可以在企业提供高性能的web服务器之外，另外还可以将本身不具备的请求通过某种预定的协议转发至其他服务器处理，不同的协议就是Nginx服务器与其他服务器进行通信的一种规范，主要在不同的场景使用以下模块实现不同的功能



```
ngx_http_proxy_module: 将客户端的请求以Http协议转发至指定服务器进行处理
ngx_stream_proxy_module：将客户端的请求以tcp协议转发至指定服务器处理
ngx_http_fastcgi_module: 将客户端对php的请求以fastcgi协议转发至指定服务器处理
ngx_http_uwsgi_module: 将客户端对Python的请求协议转发至指定服务器处理
```



![](/images/posts/03_nginx/00/16.png)

## 6.1 实现http反向代理

将用户对域wwww.nagedu.net的请求转发至后端服务器处理

官方文档：https://nginx.org/en/docs/http/ngx_http_proxy_module.html

环境准备：

```
192.168.48.141 #Nginx 代理服务器
192.168.48.142 #后端web A Apache部署
192.168.48.143 #后端web B Apache部署
```

### 6.1.1 部署后端Apache服务器

```
[root@ng-2]# yum -y install http
[root@ng-2]# echo "web1 192.168.48.142" > /var/www/html/index.html
[root@ng-2]# systemctl start httpd && systemctl enable httpd

[root@ng-3]#yum -y install httpd
[root@ng-3]#echo "web2 192.168.48.143" > /var/www/html/index.html
[root@ng-3]# systemctl start httpd && systemctl enable httpd

```

### 6.1.2 Nginx http 反向代理入门

官方文档：https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass

#### 6.2.1.1 反向代理配置参数

```
proxy_pass:
#用来设置将客户端请求转发给后端服务器的主机，可以时主机名、IP地址、端口方式，也可以代理到预先设置的主机群组，需要模块ngx_http_upstream_module支持。
location /web {
	index index.html;
	proxy_pass http://192.168.48.143:80;
	#不带斜线将访问/web，等于访问后端服务器
http://192.168.48.143:80/web/index.html,即后端服务器配置的站点根目录要有web目录才可以被访问，这是一个追加/web到后端服务器http://servername:port/web/index.html的操作

	proxy_pass http://192.168.48.143:80/;
	#带斜线，等于访问后端服务器的http://192.168.48.143:80/index.html，内容返回给客户端
}
proxy_hide_headre field;
#用于nginx作为反向代理的时候，在返回给客户端http相应的时候，隐藏后端服务器本本相应头部的信息，可以设置在Http/server或lication块
	location /web {
	index index.html;
	proxy_pass http://192.168.48.143:80/;
	proxy_hide_header ETag;
	
	}
```



```
proxy_pass_header field;
#默认nginx在相应报文中不传递后端服务器的首部字段Date，Server,X-Pad,X-Accel等参数，如果传递的话则要使用proxy_pass_header field声明将后端服务器返回的值传递给客户端
```

```
proxy_pass_request_body on | off;
#是否向后端服务器发送http包体部分，可以设置在http/server/location块，默认即为开启
```

```
proxy_pass_request_headers on | off;
#是否将客户端的请求头部转发给后端服务器，可以设置在http/server/location块，默认即为开启
```

```
proxy_set_header;
#可以更改或添加客户端的请求头部信息内容并转发至后端服务器，比如在后端服务器想要获取客户端的真实IP的时候，就要更改每一个报文的头部

#proxy_set_header X-Forwarede-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarede-For $remote_addr;
#添加HOST到报文头部，如果客户端为NAT上网那么其值为客户端的公用IP地址，尝用于在日志中记录客户端的真实IP地址
```

```
proxy_connect_timeout time;
#配置nginx服务器与后端服务器尝试建立连接的超时时间，默认为60s
proxy_connecti_timeout 60s;
#60s为自定义nginx与后端服务器建立连接的超时时间
```

```
#配置nginx服务器后端服务器或服务器组发起read请求后，等待的超时时间，默认60s
proxy_read_timeout time;
#配置nginx项后端服务器或服务器组发起write请求后，等待的超时时间，默认60s
proxy_send_timeout time;
```

```
proxy_http_version 1.0;
#用于设置http提供代理服务器的http协议的版本，默认Http1.0
```

```
proxy_ignore_client_abort off;
#当客户端网络中断请求时，nginx服务器中断其对后端服务器的请求，既如果此项设置为on开启，则服务器会忽略客户端中断并一直等着代理服务器执行返回，如果设置为off，则客户端中断后Nginx也会中断客户端立即记录499日志，默认为off
```

```
proxy_headers_hash_bucker_size 129;
#当配置了 proxy_hide_header和proxy_set_header的时候，用于设置nignx保存http报文头的hash表的上限
proxy_headers_hash_max_size 512;
#设置proxy_headers_hash_bucker_size的最大可用空间

server_names_hash_bucker_size 512;
#sercer_name ahash表申请空间大小
server_names_hash_max_size 512;
#设置服务器名称hash表的上限大小
```

#### 6.1.2.2 反向代理示例-单台web服务区

```
server {
	listen 80;
	server_name www.lcy.com;
	location / {
	proxy_pass http://192.168.48.140:80/;
	
	}

}
```

#### 6.1.2.3 反向代理示例-指定location

```
server {
	listen 80;
	server_name www.lcy.com;
	
	location / {
	index index.html;
	root /data/nginx/html;
	
	}
	location /web {
	proxy_pass http://192.168.48.140:80/;
	
	}

}
```

#### 6.1.2.4 反向代理示例-缓存功能

缓存功能默认关闭状态

```
proxy_cache zone | off; 默认off
```

```
proxy_cache_key string;
#缓存中用于键的内容，默认值：proxy_cache_key $schemem$proxy_host$request_uri;

proxy_cache_valid [code....]time;
#定义对特定响应码的相应内容的缓存时长，定义在http{..}中
示例：
proxy_cache_valid 200 302 10m;
proxy_cache_valid 404 1m;
```

```
proxy_cache_path;
定义可用于proxy功能的缓存；Context:http
proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number]
[loader_sleep=time] [loader_threshold=time] [purger=on|off][purger_files=number][purger_sleep=time]
示例：在http配置定义缓存信息
proxy_cache_path /var/cache/nginx/proxy_cache #定义缓存保存路径，proxy_cache会自动创建
levels=1:2:2 #定义缓存目录结构层次，1：2：2可用生成2……4x2^8x2^8=1-48576个目录
keys_zone=proxycache:20m #指内存中缓存的大小，主要用于存放key和metadata
inactive=120s #缓存有效时间
max_size=1g #最大磁盘占用空间，磁盘存入文件内容的缓存空间最大值

```

```
#调用缓存功能，需要定义在相应的配置段，如server{...}或者location等
	proxy_cache proxycache;
	proxy_cache_key $request_uri;
	proxy_cache_valid 200 302 301 10m;#指定的状态码返回的数据缓存多长时间
	proxy_cache_valid any 1m;
```

```
proxy_cache_use_stale error http_502 http_503;
#在被代理的后端服务器出现哪种情况下，可用直接使用过期的缓存相应客户端
proxy_cache_use_stale error |timeout | invalid_header | updating | http_500 | http_502 | http_503 http_504 | http_403 | http_404 |off; 默认时off
```

```
proxy_cache_methods GET | HEAD | POST ...；
#对哪些客户端请求方法对应的响应进行缓存，GET和HEAD方法总是被缓存
```

##### 6.1.2.4.1 非缓存场景压测

```
[root@ng-3 ~]# ab -n 2000 -c200 http://www.lcy.com/web/log.html
Total transferred:      750000 bytes
HTML transferred:       428000 bytes
Requests per second:    1116.85 [#/sec] (mean)
Time per request:       179.075 [ms] (mean)
Time per request:       0.895 [ms] (mean, across all concurrent requests)
Transfer rate:          409.00 [Kbytes/sec] received

```

##### 6.1.2.4.2 准备缓存配置

```
[root@ng-1 conf]# vim nginx.conf

proxy_cache_path /apps/nginx/proxy_cache levels=1:1:1 keys_zone=proxycache:20m inactive=
120s max_size=1g;


[root@ng-1 conf.d]# vim pc.conf
	location /web {
	index index.html;
	proxy_pass http://192.168.48.140:80;
	proxy_cache proxycache;
	proxy_cache_key $request_uri;
	proxy_cache_valid 200 302 301 1h;
	proxy_cache_valid any 1m;
	}


```

##### 6.1.2.4.3 访问并验证缓存文件

```
[root@ng-3 ~]# ab -n 2000 -c200 http://www.lcy.com/web/log.html
Total transferred:      750000 bytes
HTML transferred:       428000 bytes
Requests per second:    3648.94 [#/sec] (mean)
Time per request:       54.810 [ms] (mean)
Time per request:       0.274 [ms] (mean, across all concurrent requests)
Transfer rate:          1336.28 [Kbytes/sec] received

```

#### 6.1.2.5 添加头部报文信息

nginx基于模块ngx_http_headers_module可以实现对头部报文添加指定的key与值，https://nginx.org/en/docs/http/ngx_http_headers_module.html

```
#添加自定义首部
add_header name value [always];
	add_header X-Via $server_addr;
	add_header X-Cache $upstream_cache_status;
	add_header X-Accel $server_name;
	
#添加自定义响应信息的尾部，
add_trailer name value [always];
```

##### 6.1.2.5.1 Nginx配置

```

```

##### 6.1.2.5.2 验证头部信息

第一次访问没有使用缓存

![](/images/posts/03_nginx/00/17.png)



第二次访问命中缓存

![](/images/posts/03_nginx/00/18.png)

### 6.1.3 Nginx http 反向代理高级应用

在上一章节中Nginx可以将客户端的请求转发至单台后端服务器但是无法转发至特定一组的服务器，而且不能对后端服务器提供相应的服务器状态监测，但是Nginx可以基于ngx_http_upstream_module模块提供服务器分组转发、权重分配、状态监测、调度算法等高级功能

官方文档：https://nginx.org/en/docs/http/ngx_http_upstream_module.html

#### 6.1.3.1 http upstream配置参数

```
upstream name {

}
#自定义一组服务器，配置在http内
```

```
server address [parameters];
#配置一个后端web服务器，配置在upstream内，至少要有一个server服务器配置

#server支持的parameters如下
weight=number #设置权重，默认为1
max_conns=number #当前server设置最大活动连接数，默认为0表示没有限制。
fail_timeout=time #对后端服务器的失败检测超时时间，默认为10秒
max_fails=number #在fail_timeout时间对后端服务器连续检测失败多少次标记不可用
proxy_next_upstream=error timeout; #指定在哪种检测下将请求转发服务器其他服务器
backup #设置为备份服务器，当所有服务器不可用时将重新启用次服务器
down #标记为down状态
resolve #当server定义的是主机名的时候，当A记录发生变化会自动应用新IP而不用重启Nginx
```

```
hash KEY consistent;
#基于指定key做hash计算，使用consistent参数，将使用ketama一致性hash算法，适用于后端是cache服务器时使用，consistent定义使用一致性hash运算，一致性hash基于取模运算

hash $request_uri consistent; #基于用户请求的uri做hash
```

```
ip_hash;
#源地址hash调度方法，基于的客户端的remote_addr做hash激素按，以实现会话保持
```

```
least_conn;
#最少连接调度算法，优先将客户端请求调度到当前连接最少的后端服务器
```

#### 6.1.3.2 反向代理示例-多台web服务器

```
upstream webserver {
    #ip_hash;
	#least_conn;
	#hash $request_uri consistent;
	server 192.168.48.140 weight=1 fail_timeout=15s max_fails=3;
	server 192.168.48.141 weight=1 fail_timeout=15s max_fails=3;
}
server {
	listen 80;
	server_name www.lcy.com;
	location / {
	index index.html;
	root /data/nginx/html;
}
	location /web {
	index index.html;
	proxy_pass http://webserver/;
	}
	
}

#重启Nginx  并访问测试
[root@ng-1 conf.d]# curl http://www.lcy.com/web
192.168.48.141 app2
[root@ng-1 conf.d]# curl http://www.lcy.com/web
192.168.48.140 app1

```

## 6.2 实现Nginx tcp负载均衡

Nginx在1.9.0版本开始支持tcp模式的负载均衡，在1.9.13版本开始支持UDP协议负载，udp主要用于DNS域名解析，其配置方式和指令和http代理类似，其基于ngx_stream_proxy_module模块实现，tcp负载，另外基于模块ngx_stream_upstream_module实现后端服务器分组转发、权重分配、状态检测、调度算法等高级功能

官方文档：https://nginx.org/en/docs/stream/ngx_stream_core_module.html

### 6.2.1 tcp负载均衡配置参数

```
[root@ng-1 tcp]# cat tcp.conf 
stream { #定义stram
	upstream redis_server { #定义后端服务器
	server 192.168.48.140:6379 weight=1 fail_timeout=30s;
	}
	upstream mysql_server { #定义后端服务器
	server 192.168.48.141:3306 weight=1 fail_timeout=30s;
	}

	server {  #定义server
	listen 192.168.48.143:6379； #监听IP:PORT
	proxy_connect_timeout 30s; #连接超时时间
	proxy_timeout 300s;	#转发时间
	proxy_pass redis_server;	#转发到具体服务器组
	}
	server {
	listen 192.168.48.143:3306;
	proxy_connect_timeout 30s;
	proxy_timeout 300s;
	proxy_pass mysql_server;
	}
}

```

### 6.2.2 负载均衡示例-Redis

```
[root@ng-2 ~]# yum -y install redis
[root@ng-2 ~]# vim /etc/redis.conf
bind 0.0.0.0
....
[root@ng-2 ~]# systemctl start redis
[root@ng-2 ~]# systemctl enable redis
[root@ng-2 ~]# ss -tlnp | grep 6379
LISTEN     0      128          *:6379                     *:*                   users:(("redis-server",pid=1854,fd=4))

```

nginx配置

```
[root@ng-1 nginx]# mkdir /apps/nginx/tcp
[root@ng-1 tcp]# cat tcp.conf
stream {
	upstream redis_server {
	server 192.168.48.140:6379 weight=1 fail_timeout=30s;
	}

	server {
	listen 192.168.48.143:6379;
	proxy_connect_timeout 30s;
	proxy_timeout 300s;
	proxy_pass redis_server;
	}
}

[root@ng-1 tcp]# vim /apps/nginx/conf/nginx.conf
include /apps/nginx/tcp/*.conf; #次数的include与http模块平级

[root@ng-1 tcp]# ss -tlnp | grep 6379
LISTEN     0      128    192.168.48.143:6379                     *:*                   users:(("nginx",pid=24058,fd=13),("nginx",pid=24057,fd=13),("nginx",pid=23745,fd=13))

#测试通过nginx 负载连接redis
[root@ng-3 ~]# redis-cli -h www.lcy.com
www.lcy.com:6379> set name jack
OK
www.lcy.com:6379> get name
"jack"

```

### 6.2.3 负载均衡示例-MySQL

```
[root@ng-3 ~]# yum -y install mariadb mariadb-server
[root@ng-3 ~]# systemctl start mariadb
[root@ng-3 ~]# mysql_secure_installation
[root@ng-3 ~]# mysql -uroot -p123456
MariaDB [(none)]> GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;
MariaDB [(none)]> flush privileges;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]> exit
Bye


```

nginx配置

```
[root@ng-1 tcp]# cat tcp.conf 
stream {
	upstream redis_server {
	server 192.168.48.140:6379 weight=1 fail_timeout=30s;
	}
	upstream mysql_server {
	server 192.168.48.141:3306 weight=1 fail_timeout=30s;
	}

	server {
	listen 192.168.48.143:6379;
	proxy_connect_timeout 30s;
	proxy_timeout 300s;
	proxy_pass redis_server;
	}
	server {
	listen 192.168.48.143:3306;
	proxy_connect_timeout 30s;
	proxy_timeout 300s;
	proxy_pass mysql_server;
	}
}

#重启nginx并访问测试

[root@ng-3 ~]# mysql -uroot -p123456 -h www.lcy.com
Welcome to the MariaDB monitor.  Commands end with ; or \g.
Your MariaDB connection id is 11
Server version: 5.5.68-MariaDB MariaDB Server

Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> 

```

# 7：系统参数优化

## 7.1 系统参数优化

```
默认的Linux内核参数考虑的是最通用场景，不符合用于支持高并发访问的Web服务器的定义，根据业务特点进行调整，当Nginx作为静态web内容服务器、反向代理或者提供压缩服务器的服务器时，内核参数的调整都是不同的，此处针对最通用的、使Nginx支持更多并发请求的TCP网络参数做简单的配置，修改/etc/sysctl.conf来更改内核参数

net.ipv4.ip_nonlocal_bind = 1 #允许非本地IP地址socker监听

net.ipv4.ip_forward = 1 #开启IPV4转发
net.ipv4.tcp_timestamps = 0 #是否开启数据包时间戳
net.ipv4.tcp_tw_reuse = 0 #端口复用
net.ipv4.tcp_tw_recycle = 0 #快速回收TIME_WAIT状态，用于大量TIME_OUT场景

fs.file-max = 1000000
#表示单个进程较大可以打开的句柄数
net.ipv4.tcp_tw_reuse = 1
#参数设置为1，表示允许将TIME_WAIT状态的socker重新用于新的TCP链接，这对于服务器来说意义重大，因为总有大量TIME_WAIT状态的链接存在

net.ipv4.tcp_keepalived_time = 600
#当keepalived启动时，TCP发送keepalived消息的频度，默认时2小时，将其设置为10分钟，可更块的清理无效链接

net.ipv4.tcp_fin_timeout = 30
#当服务器主动关闭链接时，socker保持在FIN_WAIT_2状态的较大时间

net.ipv4.tcp_max_tw_buckets = 5000
#表示操作系统允许TIME_WAIT套接字数量的较大值，如超过此值，TIME_WAIT套接字将立刻被清楚并打印警告信息，默认为8000，过多的TIME_WAIT套接字会时web服务器变慢

net.ipv4.ip_local_port_range = 1024 65000
#定义UDP和TCP链接的本地端口的取值范围

net.ipv4.tcp_rmem = 10240 87380 12582912
#定义了TCP接受socker请求的缓存内存最小值、默认值、较大值

net.ipv4.tcp_wmem 10240 87380 12582912
#定义TCP发送缓存的最小值、默认值、较大值

net.core.netdev_max_backlog = 8096
#当网卡数据包的速度大于内核处理速度时，会有一个队列保存这些数据包，这个参数表示该队列的较大值

net.core.rmem_default = 6291456
#表示内核套接字接受缓存区默认大小

net.core.wmem_default = 6291456
#表示内核套接字发送缓存区默认大小

net.core.rmem_max = 12582912
#表示内核套接字接受缓存区较大大小

net.core.wmem_max = 12582912
#表示内核套接字发送缓存区交大大小

net.ipv4.tcp_syncookies = 1
#与性能无关，用于解决TCP的SYN攻击

net.ipv4.tcp_max_syn_backlog = 8192
#这个参数表示TCP三次握手建立阶段接受SYN请求队列的较大长读，默认1024，将其设置的大一些可使出先Nginx繁忙来不及accept新连接时，Linux不至于丢失客户端发起的连接请求

net.ipv4.tcp_tw_recycle = 1
#这个参数用于设置启用timewait快速回收

net.core.somaxconn=262114
#选项默认值是128，这个参数用于调节系统同时发起的TCP连接数，在高并发的请求中，默认值的可能会导致连接超时或者重传，因此需要结合高并发请求数来调节此值。

```

